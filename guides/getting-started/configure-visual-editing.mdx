---
_schema: default
_uuid: 69623165-3b7c-4868-a2e5-3fc964d040ef
_created_at: 2025-07-22T13:50:43+12:00
title: Configure Visual Editing
nav_title: Configure Visual Editing
order: 14
published: true
image: >-
  https://cc-dam.imgix.net/documentation/images/guides/getting-started/guide-thumbnails/CloudCannon-Getting-Started-Thumbnail-Universal.png
description: Learn about Sites on CloudCannon and how to set up yours.
tags: []
related_articles:
related_links: []
explicit_canonical:
---
easy to configure, add `data-editable` attribute to any DOM elements

inline editing, click directly onto the page and edit your content, no need to connect inputs.

page building, add new regions, remove old ones, and reorganize components at any time. Watch your changes come to life as you edit.

available on all SSGs cloudcannon supports

<comp.CodeBlock language="html">
``````````

<main data-editable="source" data-path="/src/pages/index.astro" data-key="main">
  <h1>Title</h1>
  <p>
    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus imperdiet, diam id faucibus accumsan, sapien tortor accumsan quam, sed auctor ex magna non ipsum. Vestibulum sed orci consequat, egestas nisi vitae, placerat lectus. Sed posuere quam vel consectetur tincidunt. Pellentesque convallis sit amet elit eget ullamcorper. Pellentesque pellentesque semper dolor eget tincidunt.
  </p>
</main>

``````````
</comp.CodeBlock>

Our blog posts all have the same format, specified by a layout. This is an example of a blog file:

<comp.CodeBlock language="markdown">
``````````

---
title: My blog post
description: Lorem ipsum dolor sit amet
pubDate: 2025-07-24T00:00:00Z
heroImage: /assets/hero-3.jpg
---
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus imperdiet, diam id faucibus accumsan, sapien tortor accumsan quam, sed auctor ex magna non ipsum. Vestibulum sed orci consequat, egestas nisi vitae, placerat lectus. Sed posuere quam vel consectetur tincidunt. Pellentesque convallis sit amet elit eget ullamcorper. Pellentesque pellentesque semper dolor eget tincidunt.

``````````
</comp.CodeBlock>

To make all the blog posts editable, we should add editable elements to the layout file. We want our content creators to be able to edit the title, publishing date, hero image, and content in the CloudCannon Visual Editor.

<comp.CodeBlock language="html">
``````````

<main>
  <article>
    <div class="hero-image">
      {
        heroImage && (
          <img
            data-editable="image"
            data-prop-source="heroImage"
            width={1020}
            height={510}
            src={heroImage}
            alt=""
          />
        )
      }
    </div>
    <div class="title">
      <h1 data-editable="text" data-prop="title">{title}</h1>
    </div>
    <div class="date">
      <FormattedDate date={pubDate} />
      {
        updatedDate && (
          <div class="last-updated-on">
            Last updated on {" "}
            <FormattedDate date={updatedDate} />
          </div>
        )
      }
    </div>
    <text-editable data-prop="@content">
      <slot />
    </text-editable>
  </article>
</main>

``````````
</comp.CodeBlock>

live rendering even for ssgs that don't have a rendering element

&nbsp;

data-editable="text" is the type of content

data-prop="" is the property we want to edit

data-prop="@content" is for when you want the non-frontmatter content

---

# Adding Visual Editing to Your Astro Site with CloudCannon

If you have an existing Astro site with markdown files and YAML frontmatter, you can easily add visual editing capabilities using CloudCannon Editables. This guide will walk you through making your content editable directly in the CloudCannon CMS.

## Overview

Your existing Astro site likely has:

* Markdown files with YAML frontmatter (`.md` files)
* Astro components (`.astro` files)
* Content collections or individual pages
* Static assets and styling

CloudCannon Editables will let your content editors:

* Edit frontmatter fields visually
* Edit markdown content with a rich text editor
* Add/remove items from arrays in frontmatter
* Upload and manage images
* Edit content without touching code

## Step 1: Install CloudCannon Editables

First, add the editables to your Astro project:

```bash
npm install @cloudcannon/editables
```

## Step 2: Make Your Frontmatter Editable

Let's say you have a blog post with this frontmatter:

```markdown
---
title: "My Blog Post"
description: "A great blog post about Astro"
author: "John Doe"
date: 2024-01-15
tags: ["astro", "web-development"]
hero_image: "/images/hero.jpg"
---

# My Blog Post

This is the content of my blog post...
```

### Making Text Fields Editable

In your Astro component that displays this content:

```astro
---
// src/pages/blog/[slug].astro or src/layouts/BlogPost.astro
const { frontmatter } = Astro.props;
---

<html>
<head>
  <title>{frontmatter.title}</title>
</head>
<body>
  <!-- Make the title editable -->
  <h1>
    <text-editable data-prop="title">{frontmatter.title}</text-editable>
  </h1>

  <!-- Make the description editable -->
  <p>
    <text-editable data-prop="description" data-type="text">
      {frontmatter.description}
    </text-editable>
  </p>

  <!-- Make the author editable -->
  <p>By: <text-editable data-prop="author">{frontmatter.author}</text-editable></p>

  <!-- The content becomes editable automatically -->
  <div>
    <text-editable data-prop="@content">
      <slot />
    </text-editable>
  </div>
</body>
</html>
```

### Alternative: Using Data Attributes

If you prefer not to use custom elements, you can use data attributes:

```astro
<h1 data-editable="text" data-prop="title">{frontmatter.title}</h1>
<p data-editable="text" data-prop="description" data-type="text">
  {frontmatter.description}
</p>
<p>By: <span data-editable="text" data-prop="author">{frontmatter.author}</span></p>
<div data-editable="text" data-prop="@content">
  <slot />
</div>
```

## Step 3: Make Arrays Editable

If your frontmatter has arrays (like tags or a team list):

```markdown
---
title: "About Us"
team_members:
  - name: "John Doe"
    role: "Developer"
    bio: "Loves coding"
  - name: "Jane Smith"
    role: "Designer"
    bio: "Creative problem solver"
tags: ["astro", "web-development", "javascript"]
---
```

Make them editable in your Astro component:

```astro
---
const { frontmatter } = Astro.props;
---

<!-- Editable team members array -->
<section>
  <h2>Our Team</h2>
  <array-editable data-prop="team_members">
    {frontmatter.team_members?.map((member, index) => (
      <array-item key={index}>
        <div class="team-member">
          <h3><text-editable data-prop="name">{member.name}</text-editable></h3>
          <p><text-editable data-prop="role">{member.role}</text-editable></p>
          <p><text-editable data-prop="bio" data-type="text">{member.bio}</text-editable></p>
        </div>
      </array-item>
    ))}
  </array-editable>
</section>

<!-- Editable simple tags array -->
<div>
  <h3>Tags:</h3>
  <array-editable data-prop="tags">
    {frontmatter.tags?.map((tag, index) => (
      <array-item key={index}>
        <span class="tag">
          <text-editable data-prop="">{tag}</text-editable>
        </span>
      </array-item>
    ))}
  </array-editable>
</div>
```

## Step 4: Make Images Editable

For image fields in your frontmatter:

```astro
---
const { frontmatter } = Astro.props;
---

<image-editable data-prop="hero_image">
  <img src={frontmatter.hero_image} alt={frontmatter.title} />
</image-editable>
```

This will allow editors to:

* Click on the image to upload a new one
* Automatically update the frontmatter with the new image path

## Step 5: Making Astro Components Editable

If you have reusable Astro components that you want to make editable, you need to register them first.

### Register Your Astro Components

Create a registration script:

```javascript
// src/scripts/register-components.js
import { registerAstroComponent } from '@cloudcannon/editables/integrations/astro.js';
import HeroSection from '../components/HeroSection.astro';
import TestimonialCard from '../components/TestimonialCard.astro';

// Register your components
registerAstroComponent('hero_section', HeroSection);
registerAstroComponent('testimonial_card', TestimonialCard);
```

Include this script in your layout:

```astro
---
// In your layout
---

<script>
  import '../scripts/register-components.js';
</script>
```

### Use Component Editables

Now you can make your components editable:

```markdown
---
title: "Homepage"
hero:
  headline: "Welcome to Our Site"
  subheading: "We build amazing things"
  cta_text: "Get Started"
testimonial:
  quote: "This company is amazing!"
  author: "Happy Customer"
---
```

```astro
<!-- In your page template -->
<component-editable data-prop="hero" data-component="hero_section">
    <HeroSection {...Astro.props.testimonial} />
</component-editable>

<component-editable data-prop="testimonial" data-component="testimonial_card">
    <TestimonialCard {...Astro.props.testimonial} />
</component-editable>
```

## Step 6: Working with Collections

If you're using Astro's content collections, you can make collection data editable:

```astro
---
// src/pages/blog/index.astro
import { getCollection } from 'astro:content';
const posts = await getCollection('blog');
---

<h1>Blog Posts</h1>
<array-editable data-prop="@collections[blog]">
  {posts.map((post) => (
    <array-item key={post.id}>
      <article>
        <h2>
          <text-editable data-prop="data.title">{post.data.title}</text-editable>
        </h2>
        <p>
          <text-editable data-prop="data.description">{post.data.description}</text-editable>
        </p>
        <a href={`/blog/${post.slug}/`}>Read more</a>
      </article>
    </array-item>
  ))}
</array-editable>
```

## Step 7: Configuration !!TODO!!

Create a `cloudcannon.config.yml` file in your project root to configure input types:

```yaml
# cloudcannon.config.yml

# Configure your collections
collections_config:
  blog:
    path: src/content/blog
    url: /blog/[slug]/
  pages:
    path: src/pages
    url: /[slug]/

# Configure input types for better editing experience
_inputs:
  title:
    type: text
  description:
    type: textarea
  content:
    type: markdown
  hero_image:
    type: image
  date:
    type: date
  tags:
    type: multiselect
    options:
      values:
        - astro
        - web-development
        - javascript
        - css
        - html

# Configure rich text editing
_editables:
  content:
    bold: true
    italic: true
    link: true
    bulletedlist: true
    numberedlist: true
    image: true
```

## Step 8: Advanced Patterns

### Conditional Content Blocks

For more complex layouts with different content block types:

```markdown
---
title: "Homepage"
content_blocks:
  - type: "hero"
    headline: "Welcome"
    image: "/hero.jpg"
  - type: "text"
    content: "Some text content"
  - type: "gallery"
    images: ["/img1.jpg", "/img2.jpg"]
---
```

```astro
<array-editable
  data-prop="content_blocks"
  data-id-key="type"
  data-component-key="type">
  {frontmatter.content_blocks?.map((block, index) => (
    <array-item key={index} data-id={block.type} data-component={`${block.type}_block`}>
        <Component {...block} />
    </array-item>
  ))}
</array-editable>
```

### Editing Layout Files

You can even make your layout files editable by using source editables:

```astro
---
// src/layouts/BaseLayout.astro
---

<html>
<head>
  <title>{title}</title>
</head>
<body>
  <header data-editable="source" data-path="/src/layouts/BaseLayout.astro" data-key="header">
    <nav>
      <a href="/">Home</a>
      <a href="/about">About</a>
      <a href="/blog">Blog</a>
    </nav>
  </header>

  <main>
    <slot />
  </main>
</body>
</html>
```

## Common Patterns and Tips

### 1\. Preserve Your Existing Structure

You don't need to change your file structure or data format. CloudCannon Editables work with your existing markdown and frontmatter.

### 2\. Gradual Migration

Start by making a few key fields editable, then gradually add more as needed:

```astro
<!-- Start simple -->
<h1><text-editable data-prop="title">{title}</text-editable></h1>

<!-- Add more complex editing later -->
<component-editable data-prop="hero" data-component="hero_section">
  <HeroSection {...hero} />
</component-editable>
```

### 4\. SEO Considerations

The editables enhance your existing content without breaking SEO:

```astro
<!-- This still renders normally for search engines -->
<meta name="description" content={frontmatter.description} />
<h1><text-editable data-prop="title">{frontmatter.title}</text-editable></h1>
```

## Troubleshooting

### Validation Errors

The system will show helpful error messages for configuration issues:

* Missing `data-prop` attributes
* Invalid data types
* Non-existent component references
* Malformed data paths

---

# CloudCannon Editables Reference

## Text Editable

Text editables allow users to edit text content with rich formatting options.

### Syntax

```html
<!-- Web Component -->
<text-editable data-prop="title" data-type="span">Default text</text-editable>

<!-- Data Attribute -->
<h1 data-editable="text" data-prop="title">Default text</h1>
```

### Required Attributes

* `data-prop` - The path to the data property (see [Path Syntax](#path-syntax))

### Optional Attributes

* `data-type` - Element type for editing behavior
  * `"span"` - Inline text editing (default for `<text-editable>`)
  * `"text"` - Paragraph-level text editing
  * `"block"` - Full rich-text editing with multiple paragraphs
* `data-defer-mount` - If present, only initializes editor when clicked

### Input Type Detection

Text editables automatically detect input configuration from CloudCannon:

```yaml
# cloudcannon.config.yml
_inputs:
  title:
    type: text        # Plain text input
  content:
    type: markdown    # Markdown editor
  rich_content:
    type: html        # Rich HTML editor
```

### Special Data Sources

* `data-prop="@content"` - Edits the main content body of markdown files
* `data-prop="@collections[name].index.property"` - Collection item properties !!TODO!!
* `data-prop="@data[filename].property"` - Data file properties !!TODO!!
* `data-prop="@file[path].property"` - Specific file properties !!TODO!!

### Error States

Text editables will show error cards for:

* Missing `data-prop` attribute
* Invalid data types (non-string values)
* Unsupported `data-type` values
* Non-existent data paths

---

## Array Editable

Array editables allow users to add, remove, and reorder items in lists.

### Syntax

```html
<!-- Web Component -->
<array-editable data-prop="team" data-id-key="id">
  <array-item data-id="1">
    <text-editable data-prop="name">John</text-editable>
  </array-item>
</array-editable>

<!-- Data Attribute -->
<div data-editable="array" data-prop="team" data-id-key="id">
  <div data-editable="array-item" data-id="1">
    <h3 data-editable="text" data-prop="name">John</h3>
  </div>
</div>
```

### Required Attributes

* `data-prop` - The path to the array property

### Optional Attributes

* `data-id-key` - Property name to use as unique identifier for array items
* `data-component-key` - Property name that determines which component to render for each item

### Array Item Attributes

Array items can have:

* `data-id` - Unique identifier (required when parent has `data-id-key`)
* `data-component` - Component name to render (when using component arrays)
* `data-prop` - Index or property path for this item's data

### Keyed vs Unkeyed Arrays

**Unkeyed Arrays** (simple lists):

```html
<array-editable data-prop="tags">
  <array-item><text-editable data-prop="">JavaScript</text-editable></array-item>
  <array-item><text-editable data-prop="">CSS</text-editable></array-item>
</array-editable>
```

**Keyed Arrays** (objects with unique IDs):

```html
<array-editable data-prop="products" data-id-key="sku">
  <array-item data-id="ABC123">
    <text-editable data-prop="name">Product Name</text-editable>
    <text-editable data-prop="price">$99</text-editable>
  </array-item>
</array-editable>
```

### Component Arrays

For arrays containing different component types:

```html
<array-editable data-prop="blocks" data-id-key="type" data-component-key="type">
  <array-item data-id="hero" data-component="hero_block"></array-item>
  <array-item data-id="text" data-component="text_block"></array-item>
</array-editable>
```

### Error States

Array editables will show error cards for:

* Missing `data-prop` attribute
* Non-array data types
* Orphaned array items (items without array parents)
* Non-existent component references

---

## Component Editable

Component editables render live components that update as data changes.

### Syntax

```html
<!-- Web Component -->
<component-editable data-prop="hero" data-component="HeroComponent"></component-editable>

<!-- Data Attribute -->
<div data-editable="component" data-prop="hero" data-component="HeroComponent"></div>
```

### Required Attributes

* `data-component` - The registered component name

### Optional Attributes

* `data-prop` - Path to data for unnamed prop
* `data-prop-{name}` - Named props (e.g., `data-prop-title="page.title"`)

### Component Registration

Components must be registered before use:

**React Components:**

```javascript
import { registerReactComponent } from '@cloudcannon/editables/integrations/react.js';
import MyComponent from './MyComponent.jsx';

registerReactComponent('my_component', MyComponent);
```

**Astro Components:**

```javascript
import { registerAstroComponent } from '@cloudcannon/editables/integrations/astro.js';
import MyComponent from './MyComponent.astro';

registerAstroComponent('my_component', MyComponent);
```

**Custom Components:** !!Dont do this!!

```javascript
window.cc_components = window.cc_components || {};
window.cc_components['my_component'] = (props) => {
  const element = document.createElement('div');
  element.innerHTML = `<h1>${props.title}</h1>`;
  return element;
};
```

### Prop Mapping

**Single Prop:**

```html
<component-editable data-prop="title" data-component="TitleComponent">
<!-- Component receives: props = "Hello World" -->
```

**Named Props:**

```html
<component-editable
  data-prop-title="page.title"
  data-prop-subtitle="page.subtitle"
  data-component="HeaderComponent">
<!-- Component receives: { title: "...", subtitle: "..." } -->
```

**Mixed Props:**

```html
<component-editable
  data-prop="hero"
  data-prop-theme="site.theme"
  data-component="HeroComponent">
<!-- Component receives: { ...heroData, theme: "dark" } -->
```

### Fine-grained Rendering

Component editables perform intelligent updates:

* Only re-render when data changes
* Preserve non-editable elements and event listeners
* Update nested editables without full re-render
* Maintain focus and cursor positions in text editables

### Error States

Component editables will show error cards for:

* Missing `data-component` attribute
* Non-existent component registrations
* Component rendering errors
* Invalid component return values

---

## Image Editable !!This one kinda sucks at the moment - exercise caution!!

Image editables provide file upload functionality for images.

### Syntax

```html
<!-- Web Component -->
<image-editable data-prop="hero_image">
  <img src="/default.jpg" alt="Hero">
</image-editable>

<!-- Data Attribute -->
<div data-editable="image" data-prop="hero_image">
  <img src="/default.jpg" alt="Hero">
</div>
```

### Required

* Must contain an `<img>` element as the first child
* `data-prop` - Path to the image property

### Behavior

Image editables automatically:

* Open file upload dialog on click
* Update the `src` attribute when new image is selected
* Call `CloudCannon.uploadFile()` to handle the upload
* Update the data property with the new image path

### Error States

Image editables will show error cards for:

* Missing `<img>` child element
* Missing `data-prop` attribute
* Upload failures

---

## Source Editable

Source editables allow direct editing of HTML or template source code.

### Syntax

```html
<!-- Web Component -->
<source-editable data-path="/src/layouts/base.astro" data-key="main">
  <main>
    <h1>Editable content</h1>
  </main>
</source-editable>

<!-- Data Attribute -->
<main data-editable="source" data-path="/src/layouts/base.astro" data-key="main">
  <h1>Editable content</h1>
</main>
```

### Required Attributes

* `data-path` - Path to the source file
* `data-key` - Unique identifier for this editable region within the file

### Behavior

Source editables:

* Parse the source file to find the editable region
* Preserve indentation and formatting
* Use js-beautify for HTML formatting
* Support nested HTML structures
* Handle void elements correctly

### Region Detection

The system finds editable regions by:

1. Locating the `data-key` attribute in the source
2. Finding the containing HTML element
3. Extracting content between opening and closing tags
4. Preserving original formatting and indentation

### Error States

Source editables will show error cards for:

* Missing `data-path` attribute
* Missing `data-key` attribute
* Non-existent file paths
* Duplicate keys within the same file

---

## Path Syntax

Data paths in `data-prop` attributes use a hierarchical dot notation to reference data properties.

### Basic Property Access

```html
<!-- Simple property -->
<text-editable data-prop="title">Title</text-editable>

<!-- Nested property -->
<text-editable data-prop="author.name">Author Name</text-editable>

<!-- Deep nesting -->
<text-editable data-prop="site.footer.copyright.text">Copyright</text-editable>
```

### Array Access

```html
<!-- Array index -->
<text-editable data-prop="tags.0">First Tag</text-editable>

<!-- Nested array property -->
<text-editable data-prop="team.0.name">First Team Member</text-editable>
```

### Special Path Prefixes

**Content Access:**

```html
<!-- Current file content -->
<text-editable data-prop="@content">Markdown content</text-editable>
```

**Collection Access:** !!TODO!!

```html
<!-- Collection array -->
<array-editable data-prop="@collections[posts]">

<!-- Specific collection item -->
<text-editable data-prop="@collections[posts].0.title">

<!-- Collection with filtering -->
<text-editable data-prop="@collections[posts].?{published==true}.0.title">
```

**Data File Access:** !!TODO!!

```html
<!-- Data file property -->
<text-editable data-prop="@data[site].title">

<!-- Nested data property -->
<text-editable data-prop="@data[navigation].0.text">
```

**External File Access:** !!TODO!!

```html
<!-- Other file property -->
<text-editable data-prop="@file[README.md].title">

<!-- Other file content -->
<text-editable data-prop="@file[about.md].@content">
```

### Path Resolution

Path resolution works hierarchically from child to parent editables:

```html
<array-editable data-prop="team">
  <array-item data-prop="0">
    <!-- This resolves to: team.0.name -->
    <text-editable data-prop="name">John</text-editable>

    <!-- This resolves to: team.0.contact.email -->
    <text-editable data-prop="contact.email">john@example.com</text-editable>

    <array-editable data-prop="skills">
      <array-item data-prop="0">
        <!-- This resolves to: team.0.skills.0 -->
        <text-editable data-prop="">JavaScript</text-editable>
      </array-item>
    </array-editable>
  </array-item>
</array-editable>
```

### Named Props in Components

Component editables support multiple prop mapping:

```html
<component-editable
  data-prop="hero"           <!-- Unnamed prop: component receives hero data -->
  data-prop-theme="site.theme"    <!-- Named prop: component receives { theme: ... } -->
  data-prop-user="current_user"   <!-- Named prop: component receives { user: ... } -->
  data-component="HeroComponent">
```

### Path Resolution Algorithm

1. **Check for absolute paths** - Paths starting with `@` are resolved from root
2. **Build relative path** - Combine current editable's path with property path
3. **Walk up hierarchy** - If property not found, try parent editable's scope
4. **Apply to data** - Use resolved path to get/set data value

### Advanced Path Features !!TODO!!

**Conditional Access:**

```html
<!-- Find first published post -->
<text-editable data-prop="@collections[posts].?{published==true}.0.title">
```

## Note: Advanced features may require additional configuration or may be framework-specific.

## Visual Editor Previews

In a previous section of this guide, we talked about the Visual Editor — an intuitive way to edit your site by clicking directly on a preview of your page. But how do you make each region editable in the Visual Editor?

### Bookshop

<a target="_blank" rel="noreferrer noopener" href="https://github.com/CloudCannon/bookshop/">Bookshop</a> is our open-source tool to automate maintaining page components for page building. Using Bookshop, your team can update the front matter of each page component in the Visual Editor. CloudCannon will re-render your page as changes occur, generating a preview of your page as you edit.

To get started with Bookshop, read our <a target="_blank" rel="noreferrer noopener" href="https://cloudcannon.com/documentation/guides/bookshop-astro-guide/">Astro Bookshop guide</a>, or <a target="_blank" rel="noreferrer noopener" href="https://cloudcannon.com/documentation/support/">reach out to our support team</a>.

---

## Bookshop

A common feature of modern website builders is the ability to add and move content blocks to build custom page layouts from defined components. We’ve created <a target="_blank" rel="noopener" href="https://github.com/CloudCannon/bookshop">Bookshop</a> to automate maintaining page components for page building. Bookshop is an open-source component library compatible with Astro, Eleventy, Hugo, Jekyll, and SvelteKit. It’s simple to introduce and has tight integration into CloudCannon, which will handle most of the setup.

To get started with Bookshop, read our <a target="_blank" rel="noopener" href="https://github.com/CloudCannon/bookshop/">Bookshop guide</a> or <a target="_blank" rel="noopener" href="https://cloudcannon.com/documentation/support/">reach out to our support team</a>.

---

## Visual Editor Previews

In a previous section of this guide, we talked about the Visual Editor — an intuitive way to edit your site by clicking directly on a preview of your page. But how do you make each region editable in the Visual Editor?

### React Connector

The <a target="_blank" rel="noreferrer noopener" href="https://github.com/CloudCannon/react-connector">React Connector</a> is our open-source tool which listens for live editing events in the Visual Editor. CloudCannon will re-render your page as changes occur, generating a preview of your page as you edit.

CloudCannon React Connector is available on npm. To install it, run the following terminal command:

<comp.CodeBlock language="" source="">
    ```
        npm i @cloudcannon/react-connector
    ```
    </comp.CodeBlock>

Update the code in `pages/_app.jsx` from:

<comp.CodeBlock language="JavaScript" source="">
    ```
        export default function App({ Component, pageProps }) {
        	return <Component {...pageProps} />
        }
        ```
        </comp.CodeBlock>

        to:

        <comp.CodeBlock language="JavaScript" source="">
        ```
        import { CloudCannonConnect } from '@cloudcannon/react-connector'

        export default function App({ Component, pageProps }) {
        	const AppComponent = CloudCannonConnect(Component);
        	return <AppComponent {...pageProps}/>
        }
    ```
    </comp.CodeBlock>

CloudCannon will now push changes made to front matter in the Visual Editor directly into page props. This will display the new values in the Visual Editor immediately.

For more react connector options, read our <a target="_blank" rel="noreferrer noopener" href="https://github.com/CloudCannon/react-connector">GitHub React Connector guide</a>, or <a target="_blank" rel="noopener" href="https://cloudcannon.com/documentation/support/">reach out to our support team</a>.

---

## Visual Editor Previews

In a previous section of this guide, we talked about the Visual Editor — an intuitive way to edit your site by clicking directly on a preview of your page. But how do you make each region editable in the Visual Editor?

### Editable class

To edit HTML in the Visual Editor, add the class ‘editable’ to HTML elements. This way, you can give as much or as little access to your content team as you need.

You can define add the ‘editable’ class to your site in the Source Editor:

<comp.CodeBlock language="HTML" source="homepage.html">
    ```
        <p class="editable">I'm editable in the visual editor</p>
        <p>I'm <strong>not</strong> editable in the visual editior</p>
    ```
    </comp.CodeBlock>

The element you apply the ‘editable’ class to will change the editing options in the WYSIWYG toolbar. For example, adding the editable class to an &lt;h1&gt; element will provide basic text formatting options. Adding it to a &lt;div&gt; element will open the option to add images, lists, and tables. You can [customize the WYSIWYG toolbar](/documentation/articles/configuring-toolbars) to have complete control over what editors can and cannot add to each element.

<comp.Notice info_type="info">
  Changes made to the HTML save back to your layout, which might affect multiple content files.
</comp.Notice>

---

## Visual Editor Previews

In a previous section of this guide, we talked about the Visual Editor — an intuitive way to edit your site by clicking directly on a preview of your page. But how do you make each region editable in the Visual Editor?

### Editable class

To edit HTML in the Visual Editor, add the class ‘editable’ to HTML elements. This way, you can give as much or as little access to your content team as you need.

You can define add the ‘editable’ class to your site in the Source Editor:

<comp.CodeBlock language="HTML" source="homepage.html">
    ```
          <p class="editable">I'm editable in the visual editor</p>
          <p>I'm <strong>not</strong> editable in the visual editior</p>
    ```
    </comp.CodeBlock>

The element you apply the ‘editable’ class to will change the editing options in the WYSIWYG toolbar. For example, adding the editable class to an &lt;h1&gt; element will provide basic text formatting options. Adding it to a `<div>` element will open the option to add images, lists, and tables. You can [customize the WYSIWYG toolbar](/documentation/articles/configuring-toolbars) to have complete control over what editors can and cannot add to each element.

<comp.Notice info_type="info">
  Changes made to the HTML save back to your layout, which might affect multiple content files.
</comp.Notice>

---

## Visual Editor Previews

In a previous section of this guide, we talked about the Visual Editor — an intuitive way to edit your site by clicking directly on a preview of your page. But how do you make each region editable in the Visual Editor?

### Editable class

To edit HTML in the Visual Editor, add the class ‘editable’ to HTML elements. This way, you can give as much or as little access to your content team as you need.

You can define add the ‘editable’ class to your site in the Source Editor:

<comp.CodeBlock language="HTML" source="homepage.html">
    ```
                <p class="editable">I'm editable in the visual editor</p>
                <p>I'm <strong>not</strong> editable in the visual editior</p>
    ```
    </comp.CodeBlock>

The element you apply the ‘editable’ class to will change the editing options in the WYSIWYG toolbar. For example, adding the editable class to an &lt;h1&gt; element will provide basic text formatting options. Adding it to a &lt;div&gt; element will open the option to add images, lists, and tables. You can [customize the WYSIWYG toolbar](/documentation/articles/configuring-toolbars) to have complete control over what editors can and cannot add to each element.

<comp.Notice info_type="info">
  Changes made to the HTML save back to your layout, which might affect multiple content files.
</comp.Notice>

---

&nbsp;

&nbsp;