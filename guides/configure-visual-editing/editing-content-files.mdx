---
_schema: default
_uuid: 9cfb6628-42ff-4598-9556-9722d672d0a9
_created_at: 2025-08-26T11:26:57+12:00
title: Editing content files
nav_title: Editing content files
order: 3
published: true
start_nav_group:
image: >-
  https://cc-dam.imgix.net/documentation/images/guides/getting-started/guide-thumbnails/CloudCannon-Getting-Started-Thumbnail-Universal.png
description: >-
  Learn how to configure CloudCannon Editables for your content files, including
  YAML front matter and Markdown content.
---
Most content files are hybrid files, with a YAML front matter section containing file information in structured data keys (e.g., `title`, `publish_date`, `author`, etc.) and the main body of content in Markdown. The structured data and content from each file populate fields in a layout file containing the HTML-like templating to generate the output page during a Site build.

Let's take a look at an example. Even though this example is for the SSG Astro, most SSGs that CloudCannon supports will use a similar model (i.e., populating a layout file with values from each content file to generate a page).

This file is a blog post, containing structured data keys for `title`, `description`, `author`, `pubDate`, and `heroImage` in the front matter, and Markdown content in the body of the file.

<comp.CodeBlock language="markdown" source="first-post.mdx">
``````````

---
title: 'First post'
description: 'Lorem ipsum dolor sit amet'
author: 'C. Kent'
pubDate: 'Jul 08 2022'
heroImage: '../../assets/blog-placeholder-3.jpg'
---

Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Vitae ultricies leo integer malesuada nunc vel risus commodo viverra.

``````````
</comp.CodeBlock>

This file is the blog layout, containing templating for the values of each blog file.

<comp.CodeBlock language="Astro" source="BlogPost.astro">
``````````

---
import { Image } from 'astro:assets';
import type { CollectionEntry } from 'astro:content';
import BaseHead from '../components/BaseHead.astro';
import Footer from '../components/Footer.astro';
import FormattedDate from '../components/FormattedDate.astro';
import Header from '../components/Header.astro';

type Props = CollectionEntry<'blog'>['data'];

const { title, description, author, pubDate, updatedDate, heroImage } = Astro.props;
---

<html lang="en">
	<body>
		<Header />
		<main>
			<article>
				<div class="hero-image">
                    {heroImage &&
                        <img /*1*/
                          width={1020}
                          height={510}
                          src={heroImage}
                          alt=""
                        />
                      }
				</div>
				<div class="prose">
					<div class="title">
						<div class="date">
							<FormattedDate date={pubDate} /> /*2*/
							{
								updatedDate && (
									<div class="last-updated-on">
										Last updated on <FormattedDate date={updatedDate} />
									</div>
								)
							}
						</div>
						<h1>{title}</h1> /*3*/
                        <p>By: {author}</p> /*4*/
						<hr />
					</div>
					<slot /> /*5*/
				</div>
			</article>
		</main>
		<Footer />
	</body>
</html>

``````````
<comp.Annotation number="1">
  This `<img>` element contains image width, height, source, and alt text attributes. The `src` attribute is set to the template `{heroImage}`, which draws its value from the `heroImage` key in the front matter of a blog file.
</comp.Annotation>
<comp.Annotation number="2">
  This `<FormattedDate>` element contains a date attribute, set to the template `{pubDate}`. This value comes from the `pubDate` key in the front matter of a blog file.
</comp.Annotation>
<comp.Annotation number="3">
  This `<h1>` element surrounds the template value `{title}`. This value comes from the `title` key in the front matter of a blog file.
</comp.Annotation>
<comp.Annotation number="4">
  This `<p>` element surrounds the template value `{author}`, prepended by the plain text "By:". This value comes from the `author` key in the front matter of a blog file.
</comp.Annotation>
<comp.Annotation number="5">
  This `<slot />` element marks where the markup content from a blog file will go.
</comp.Annotation>
</comp.CodeBlock>

Together, these files output a webpage that looks like this:

<comp.DocsImage path="" alt="" title=""/>

When you open a content file like `first-post.mdx` in the Visual Editor, CloudCannon will automatically add Inputs to the sidebar for you to edit the structured data in your front matter, but you can't change your content or edit directly on the page. Let's fix that by adding CloudCannon Editables to your blog layout file.

<comp.DocShot docshot_key="" alt="" title=""/>

In this step of the guide, we'll add the following components and attributes:

* `data-editable=""` —
* `data-prop=""` — This attribute defines the path to the data property you want to edit.
* `<text-editable>` — This web component allows you to wrap other elements and apply Editable attributes. This is useful if you want to edit an element that can't take attributes.

For a complete list of configuration options for CloudCannon Editables, please read our [Editables reference](/documentation/articles/editables-reference) documentation.

## Text in your front matter

In our example above, there are two text front matter keys we want to edit: `title` and `author`.

In the blog layout, the `{title}` templating inside the `<h1>` tag is populated by the value of the `title` key in the front matter of each blog file. To allow CloudCannon to re-render this field in the Visual Editor for inline editing, we need to add the `data-editable=""` and `data-prop=""` attributes to the `<h1>` tag in the blog layout.

The value for `data-editable` should be `text`, as text is the type of data stored under the `title` key. The value for `data-prop` should be `title`, as this is the path to the data property we want to edit (we'll dive deeper into paths for the `data-prop` attribute in the [Advanced data property paths]() step of this guide).

Here's what our blog layout code should look like:

<comp.CodeBlock language="Astro" source="BlogPost.astro">
``````````

<h1 data-editable="text" data-prop="title" >{title}</h1> /*1*/

``````````
<comp.Annotation number="1">
  The `data-editable` attribute defines what kind of data this element contains. In this case, the value is `text`. The `data-prop` attribute defines where data is stored. In this case, we are editing the value of the `title` key in the file front matter.
</comp.Annotation>
</comp.CodeBlock>

Editing the blog author is slightly more complicated.

In the blog layout, the `{author}` templating inside the `<p>` tag is populated by the value of the `author` key in the front matter of each blog file. Just like the title example, we need to add the `data-editable="text"` and `data-prop="author"` attributes to enable inline editing in the Visual Editor. However, if we add those attributes directly to the `<p>` tag, we won't be able to see the "By:" plain text that prepends the author value.

If we add `<p data-editable="text" data-prop="author">` to our blog layout, the Visual Editor would re-render to the field to show the value of `author`, hiding the plain text. It is important to note that Text Editables don't modify the code of your templating, so the "By:" plain text is not destroyed. Instead, they update the value of the front matter key and re-render the webpage preview. This leads to a mismatch in the appearance of the built Site, which includes "By:" before the author name, and the preview in the Visual Editor, which would not.

To avoid this issue, we can specifically wrap the `{author}` templating in a `<text-editable>` web component. The `<text-editable>` component replaces the need for the `data-editable="text"` attribute, telling CloudCannon what type of data we are editing. We can add the `data-prop="author"` attribute to this web component.

Here's what our blog layout code should look like:

<comp.CodeBlock language="Astro" source="BlogPost.astro">
``````````

<p>By: <text-editable data-prop="author">{author}</text-editable></p> /*1*/

``````````
<comp.Annotation number="1">
  The `data-editable` attribute defines what kind of data this element contains. In this case, the value is `text`. The `data-prop` attribute defines where data is stored. In this case, we are editing the value of the `title` key in the file front matter.
</comp.Annotation>
</comp.CodeBlock>

&nbsp;

## Images in your front matter

x

This file is the blog layout, containing templating for the values of each blog file.

<comp.CodeBlock language="Astro" source="BlogPost.astro">
``````````

<div class="hero-image">
    {heroImage &&
      <img
        data-editable="image" /*1*/
        data-prop-src="heroImage" /*2*/
        width={1020}
        height={510}
        src={heroImage}
        alt=""
      />
    }
</div>

``````````
<comp.Annotation number="1">
  The `data-editable` attribute defines what kind of data this element contains. In this case, the value is `image`.
</comp.Annotation>
<comp.Annotation number="2">
  The `data-prop-src` attribute defines where data is stored. In this case, we are editing the value of the `heroImage` key in the file front matter.
</comp.Annotation>
</comp.CodeBlock>

## Dates in your front matter

In our example, there are three types of structured data....

This file is the blog layout, containing templating for the values of each blog file.

<comp.CodeBlock language="Astro" source="BlogPost.astro">
``````````

<div class="date">
    <FormattedDate date={pubDate} /> /*1*/
    {
        updatedDate && (
            <div class="last-updated-on">
                Last updated on <FormattedDate date={updatedDate} />
            </div>
        )
    }
</div>

``````````
<comp.Annotation number="1">
  This `<img>` element contains image width, height, source, and alt text attributes. The `src` attribute is set to the template `{heroImage}`, which draws its value from the `heroImage` key in the front matter of a blog file.
</comp.Annotation>
</comp.CodeBlock>

Together, these files output a webpage that looks like this:

## Markdown content

x

<comp.CodeBlock language="Astro" source="BlogPost.astro">
``````````

<text-editable data-editable="@content"> /*1*/
    <slot />
</text-editable>

``````````
<comp.Annotation number="1">
  The `<slot />` element is wrapped in the `<text-editable>` web component, which can take Editable attributes. The `data-prop` attribute defines where data is stored. In this case, we are editing the content of the file outside of the front matter, signified by the special value `@content`.
</comp.Annotation>
</comp.CodeBlock>

Because `<slot />` is not a DOM element, we need to add one