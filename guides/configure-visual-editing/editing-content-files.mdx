---
_schema: default
_uuid: 9cfb6628-42ff-4598-9556-9722d672d0a9
_created_at: 2025-08-26T11:26:57+12:00
title: Editing content files
nav_title: Editing content files
order: 3
published: true
start_nav_group:
image: >-
  https://cc-dam.imgix.net/documentation/images/guides/getting-started/guide-thumbnails/CloudCannon-Getting-Started-Thumbnail-Universal.png
description: >-
  Learn how to configure CloudCannon Editables for your content files, including
  YAML front matter and Markdown content.
---
Most content files are hybrid files, with a YAML front matter section containing file information in structured data keys (e.g., `title`, `publish_date`, `author`, etc.) and the main body of content in Markdown. The structured data and content from each file populate fields in a layout file, which contains the HTML-like templating to generate the output page during a Site build.

Let's take a look at an example. Even though this example is for the SSG Astro, most SSGs that CloudCannon supports will use a similar model (i.e., populating a layout file with values from each content file to generate a page).

This file is a blog post, containing structured data keys for `title`, `description`, `author`, `pubDate`, and `heroImage` in the front matter, and Markdown content in the body of the file.

<comp.CodeBlock language="markdown" source="first-post.mdx">
``````````

---
title: 'First post'
description: 'Lorem ipsum dolor sit amet'
author: 'C. Kent'
pubDate: 'Jul 08 2022'
heroImage: '../../assets/blog-placeholder-3.jpg'
---

Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Vitae ultricies leo integer malesuada nunc vel risus commodo viverra.

``````````
</comp.CodeBlock>

This file is the blog layout, containing HTML layout for the blog webpage and templating to populate elements with the values from each blog file.

<comp.CodeBlock language="Astro" source="BlogPost.astro">
``````````

---
import { Image } from 'astro:assets';
import type { CollectionEntry } from 'astro:content';
import BaseHead from '../components/BaseHead.astro';
import Footer from '../components/Footer.astro';
import FormattedDate from '../components/FormattedDate.astro';
import Header from '../components/Header.astro';

type Props = CollectionEntry<'blog'>['data'];

const { title, description, author, pubDate, updatedDate, heroImage } = Astro.props;
---

<html lang="en">
	<body>
		<Header />
		<main>
			<article>
				<div class="hero-image">
                    {heroImage &&
                        <img /*1*/
                          width={1020}
                          height={510}
                          src={heroImage}
                          alt=""
                        />
                      }
				</div>
				<div class="prose">
					<div class="title">
						<div class="date">
							<FormattedDate date={pubDate} />
							{
								updatedDate && (
									<div class="last-updated-on">
										Last updated on <FormattedDate date={updatedDate} />
									</div>
								)
							}
						</div>
						<h1>{title}</h1> /*2*/
                        <p>By: {author}</p> /*3*/
						<hr />
					</div>
					<slot /> /*4*/
				</div>
			</article>
		</main>
		<Footer />
	</body>
</html>

``````````
<comp.Annotation number="1">
  This `<img>` element contains image width, height, source, and alt text attributes. The `src` attribute is set to the template `{heroImage}`, which draws its value from the `heroImage` key in the front matter of a blog file.
</comp.Annotation>
<comp.Annotation number="2">
  This `<h1>` element surrounds the template value `{title}`. This value comes from the `title` key in the front matter of a blog file.
</comp.Annotation>
<comp.Annotation number="3">
  This `<p>` element surrounds the template value `{author}`, prepended by the plain text "By:". This value comes from the `author` key in the front matter of a blog file.
</comp.Annotation>
<comp.Annotation number="4">
  This `<slot />` element marks where the markup content from a blog file will go.
</comp.Annotation>
</comp.CodeBlock>

Together, these files output a webpage that looks like this:

<comp.DocsImage path="" alt="" title=""/>

When you open a content file like `first-post.mdx` in the Visual Editor, CloudCannon will automatically add Inputs to the sidebar for you to edit the structured data in your front matter, but you can't change your content or edit directly on the page. Let's fix that by adding CloudCannon Editables to your blog layout file.

<comp.DocShot docshot_key="" alt="" title=""/>

In this step of the guide, we'll add the following components and attributes:

* `data-editable=""` — This attribute defines the type of data as `array`, `array-item`, `component`, `image`, `source`, or `text`.
* `data-prop=""` — This attribute defines the path to the data property you want to edit.
* `<text-editable>` — This web component defines the type of data as `text` and allows you to wrap other elements. This is useful if you want to edit an element that can't take attributes or a specific section of a string.

For a complete list of configuration options for CloudCannon Editables, please read our [Editables reference](/documentation/articles/editables-reference) documentation.

## Text in your front matter

In our example above, there are two text front matter keys we want to edit: `title` and `author`.

In the blog layout, the `{title}` templating inside the `<h1>` tag is populated by the value of the `title` key in the front matter of each blog file. To allow CloudCannon to re-render this field in the Visual Editor for inline editing, we need to add the `data-editable=""` and `data-prop=""` attributes to the `<h1>` tag in the blog layout.

The value for `data-editable` should be `text`, as text is the type of data stored under the `title` key. The value for `data-prop` should be `title`, as this is the path to the data property we want to edit (we'll dive deeper into paths for the `data-prop` attribute in the [Advanced data property paths]() step of this guide).

Here's what our blog layout code should look like:

<comp.CodeBlock language="Astro" source="BlogPost.astro">
``````````

<h1 data-editable="text" data-prop="title" >{title}</h1> /*1*/

``````````
<comp.Annotation number="1">
  The `data-editable` attribute defines what kind of data this element contains. In this case, the value is `text`. The `data-prop` attribute defines where data is stored. In this case, we are editing the value of the `title` key in the file front matter.
</comp.Annotation>
</comp.CodeBlock>

Editing the blog author is slightly more complicated.

In the blog layout, the `{author}` templating inside the `<p>` tag is populated by the value of the `author` key in the front matter of each blog file. Just like the title example, we need to add the `data-editable="text"` and `data-prop="author"` attributes to enable inline editing in the Visual Editor. However, if we add those attributes directly to the `<p>` tag, we won't be able to see the "By:" plain text that prepends the author value.

If we add `<p data-editable="text" data-prop="author">` to our blog layout, the Visual Editor would re-render the field to only show the value of `author`, hiding the plain text. It is important to note that Text Editables don't modify the code of your templating, so the "By:" plain text is not destroyed. Instead, they update the value of the front matter key and re-render the webpage preview. This leads to a mismatch in the appearance of the built Site, which includes "By:" before the author name, and the preview in the Visual Editor, which would not.

To avoid this issue, we can specifically wrap the `{author}` templating in a `<text-editable>` web component. The `<text-editable>` component replaces the need for the `data-editable="text"` attribute, telling CloudCannon what type of data we are editing. We can add the `data-prop="author"` attribute to this web component.

Here's what our blog layout code should look like:

<comp.CodeBlock language="Astro" source="BlogPost.astro">
``````````

<p>By: <text-editable data-prop="author">{author}</text-editable></p> /*1*/

``````````
<comp.Annotation number="1">
  The `<text-editable>` web component defines what kind of data this element contains and takes other Editables attributes. The `data-prop` attribute defines where data is stored. In this case, we are editing the value of the `title` key in the file front matter.
</comp.Annotation>
</comp.CodeBlock>

If we save and rebuild our Site, yellow boxes showing editable regions will appear around the title and author fields in the Visual Editor, enabling inline editing of those values.

<comp.DocShot docshot_key="" alt="" title=""/>

## Markdown content

Editing the body of a content file in the Visual Editor is the most intuitive editing experience for CloudCannon users. Let's add a Text Editable to our content.

In the blog layout, the `<slot />` element is populated by the Markdown content in the main body of each blog file. However, because `<slot />` is not a DOM element, we can't add the `data-editable=""` and `data-prop=""` attributes directly. To get around this issue, we can wrap the `<slot />` element in a `<text-editable>` web component which can take attributes.

The `<text-editable>` component replaces the need for the `data-editable="text"` attribute, telling CloudCannon what type of data we are editing. But, what is the value of the `data-prop=""` attribute? There are no front matter keys we can reference to tell CloudCannon where the data is stored.

In this case, we can use the special value `@content` to specify Markdown content in the body of a content file.

Here's what our blog layout code should look like:

<comp.CodeBlock language="Astro" source="BlogPost.astro">
``````````

<text-editable data-prop="@content"> /*1*/
    <slot />
</text-editable>

``````````
<comp.Annotation number="1">
  The `<slot />` element is wrapped in the `<text-editable>` web component, which can take Editable attributes. The `data-prop` attribute defines where data is stored. In this case, we are editing the content of the file outside of the front matter, signified by the special value `@content`.
</comp.Annotation>
</comp.CodeBlock>

If we save and rebuild our Site, a yellow box showing an editable region will appear around the blog content in the Visual Editor, enabling inline editing.

<comp.DocShot docshot_key="" alt="" title=""/>

## Images in your front matter

You can also add an Image Editable to images, allowing user to upload a new image in the Visual Editor.

In this example, each blog file references an image path under the `heroImage` key, which populates the `<img>` tag in the blog layout (`src` is set to `{heroImage}`). To allow CloudCannon to re-render this image in the Visual Editor and let select a new image path, we need to add the `data-editable=""` and `data-prop-src=""` attributes to the `<img>` tag in the blog layout.

The value for `data-editable` should be `image`, as an image path is the type of data stored under the `heroImage` key.

Next we'll add `data-prop-src`. The `data-prop-src` attribute is an extension of the `data-prop` attribute. Both define the location of the data property you want to edit. However, `data-prop` only passes the value stored at that location to the Editable (e.g., `/example.jpg`), while `data-prop-src` also renames the value with the `src` key (e.g., `src: /example.jpg`).

CloudCannon Image Editables expect data in the `src: string` format. By adding the add the `data-prop-src="heroImage"` attribute to the `<img>` tag, we can take the value of the `heroImage` key in the front matter, append the key `src`, adn pass it to our Image Editable (we'll dive deeper into the `data-prop` attribute in the [Advanced data property paths]() step of this guide).

Here's what our blog layout code should look like:

<comp.CodeBlock language="Astro" source="BlogPost.astro">
``````````

<div class="hero-image">
    {heroImage &&
      <img
        data-editable="image" /*1*/
        data-prop-src="heroImage" /*2*/
        width={1020}
        height={510}
        src={heroImage}
        alt=""
      />
    }
</div>

``````````
<comp.Annotation number="1">
  The `data-editable` attribute defines what kind of data this element contains. In this case, the value is `image`.
</comp.Annotation>
<comp.Annotation number="2">
  The `data-prop-src` attribute defines where data is stored. In this case, we are editing the value of the `heroImage` key in the file front matter.
</comp.Annotation>
</comp.CodeBlock>

If we save and rebuild our Site, a yellow box showing an editable region will appear around the blog image in the Visual Editor.

<comp.DocShot docshot_key="" alt="" title=""/>

<comp.Notice info_type="important">
  <p>We do not recommend nesting Image Editables inside Text Editables.</p>
</comp.Notice>

In the next step of this guide, we'll cover how to edit webpages generated from HTML-like files by adding a Source Editable.