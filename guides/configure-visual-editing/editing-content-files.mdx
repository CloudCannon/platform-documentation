---
_schema: default
_uuid: 9cfb6628-42ff-4598-9556-9722d672d0a9
_created_at: 2025-08-26T11:26:57+12:00
title: Editing content files
nav_title: Editing content files
order: 3
published: true
start_nav_group:
image: >-
  https://cc-dam.imgix.net/documentation/images/guides/getting-started/guide-thumbnails/CloudCannon-Getting-Started-Thumbnail-Universal.png
description: >-
  Learn how to configure CloudCannon Editables for your content files, including
  YAML front matter and Markdown content.
---
Most content files are hybrid files, with a YAML front matter section containing file information in structured data keys (e.g., `title`, `publish_date`, `author`, etc.) and the main body of content in Markdown. The structured data and content from each file populate fields in a layout file, which contains the HTML-like templating to generate the output page during a Site build.

Let's take a look at an example. Even though this example is for the SSG Astro, most SSGs that CloudCannon supports will use a similar model (i.e., populating a layout file with values from each content file to generate a page).

This file is a blog post, containing structured data keys for `title`, `description`, `author`, `pubDate`, and `heroImage` in the front matter, and Markdown content in the body of the file.

<comp.CodeBlock language="markdown" source="first-post.mdx">
``````````

---
title: 'First post'
description: 'Lorem ipsum dolor sit amet'
author: 'C. Kent'
pubDate: 'Jul 08 2022'
heroImage: '../../assets/blog-placeholder-3.jpg'
---

Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Vitae ultricies leo integer malesuada nunc vel risus commodo viverra.

``````````
</comp.CodeBlock>

This file is the blog layout, containing HTML layout for the blog webpage and templating to populate elements with the values from each blog file.

<comp.CodeBlock language="Astro" source="BlogPost.astro">
``````````

---
import { Image } from 'astro:assets';
import type { CollectionEntry } from 'astro:content';
import BaseHead from '../components/BaseHead.astro';
import Footer from '../components/Footer.astro';
import FormattedDate from '../components/FormattedDate.astro';
import Header from '../components/Header.astro';

type Props = CollectionEntry<'blog'>['data'];

const { title, description, author, pubDate, updatedDate, heroImage } = Astro.props;
---

<html lang="en">
	<body>
		<Header />
		<main>
			<article>
				<div class="hero-image">
                    {heroImage &&
                        <img /*1*/
                          width={1020}
                          height={510}
                          src={heroImage}
                          alt=""
                        />
                      }
				</div>
				<div class="prose">
					<div class="title">
						<div class="date">
							<FormattedDate date={pubDate} />
						</div>
						<h1>{title}</h1> /*2*/
                        <p>By: {author}</p> /*3*/
						<hr />
					</div>
					<slot /> /*4*/
				</div>
			</article>
		</main>
		<Footer />
	</body>
</html>

``````````
<comp.Annotation number="1">
  This `<img>` element contains image width, height, source, and alt text attributes. The `src` attribute is set to the template `{heroImage}`, which draws its value from the `heroImage` key in the front matter of a blog file.
</comp.Annotation>
<comp.Annotation number="2">
  This `<h1>` element surrounds the template value `{title}`. This value comes from the `title` key in the front matter of a blog file.
</comp.Annotation>
<comp.Annotation number="3">
  This `<p>` element surrounds the template value `{author}`, prepended by the plain text "By:". This value comes from the `author` key in the front matter of a blog file.
</comp.Annotation>
<comp.Annotation number="4">
  This `<slot />` element marks where the markup content from a blog file will go.
</comp.Annotation>
</comp.CodeBlock>

Together, these files output a webpage that looks like this:

<comp.DocsImage path="" alt="" title=""/>

When you open a content file like `first-post.mdx` in the Visual Editor, CloudCannon will automatically add Inputs to the sidebar for you to edit the structured data in your front matter, but you can't change your content or edit it directly on the page.

<comp.DocShot docshot_key="" alt="" title=""/>

Let's fix that by adding Text and Image Editables to your blog layout file.

In this step of the guide, we'll add the following components and attributes:

* `data-editable="text"` and `<text-editable>` — This attribute, and its equivalent web component, defines the data type inside an Editable as `text`.
* `data-editable="image"` and `<image-editable>` — This attribute, and its equivalent web component, defines the data type inside an Editable as `image`.
* `data-prop=""` — This attribute defines the path to the data property you want to edit and passes that value to the CloudCannon Editable.
* `data-prop-src=""` — This attribute defines the path to the data property you want to edit and passes that value to the CloudCannon Editable with the `src` key.

For a complete list of configuration options for CloudCannon Editables, please read our [Editables reference](/documentation/articles/editables-reference) documentation.

## Text in your front matter

In our example above, there are two text front matter keys we want to edit: `title` and `author`.

In the blog layout, the `{title}` templating inside the `<h1>` tag is populated by the value of the `title` key in the front matter of each blog file. To allow CloudCannon to re-render this field in the Visual Editor for inline editing, we need to add the `data-editable=""` and `data-prop=""` attributes to the `<h1>` tag in the blog layout.

The value for `data-editable` should be `text`, as text is the type of data stored under the `title` key. The value for `data-prop` should be `title`, as this is the path to the data property we want to edit (we'll dive deeper into paths for the `data-prop` attribute in the [Advanced data property paths]() step of this guide).

Here's what our blog layout code should look like:

<comp.CodeBlock language="Astro" source="BlogPost.astro">
``````````

<h1 data-editable="text" data-prop="title" >{title}</h1> /*1*/

``````````
<comp.Annotation number="1">
  The `data-editable` attribute defines what kind of data this element contains. In this case, the value is `text`. The `data-prop` attribute defines where data is stored. In this case, we are editing the value of the `title` key in the file front matter.
</comp.Annotation>
</comp.CodeBlock>

Editing the blog author is slightly more complicated.

In the blog layout, the `{author}` templating inside the `<p>` tag is populated by the value of the `author` key in the front matter of each blog file. Just like the title example, we need to add the `data-editable="text"` and `data-prop="author"` attributes to enable inline editing in the Visual Editor. However, if we add those attributes directly to the `<p>` tag, we won't be able to see the "By:" plain text that prepends the author value.

If we added `<p data-editable="text" data-prop="author">` to our blog layout, the Visual Editor would re-render the field to only show the value of `author`, hiding the plain text. It is important to note that Text Editables don't modify the code of your templating, so the "By:" plain text is not destroyed. Instead, they update the value of the front matter key and re-render the webpage preview. This leads to a mismatch in the appearance of the built Site, which includes "By:" before the author name, and the preview in the Visual Editor, which would not.

To avoid this issue, we can specifically wrap the `{author}` templating in a `<text-editable>` web component. The `<text-editable>` component replaces the need for the `data-editable="text"` attribute, telling CloudCannon what type of data we are editing. This is useful if you want to edit an element that can't take attributes or a specific section of a string. We can add the `data-prop="author"` attribute to this web component.

Here's what our blog layout code should look like:

<comp.CodeBlock language="Astro" source="BlogPost.astro">
``````````

<p>By: <text-editable data-prop="author">{author}</text-editable></p> /*1*/

``````````
<comp.Annotation number="1">
  The `<text-editable>` web component defines what kind of data this element contains and takes other Editable attributes. The `data-prop` attribute defines the path to the data property you want to edit and passes that value to the CloudCannon Editable. In this case, we are editing the value of the `title` key in the file front matter.
</comp.Annotation>
</comp.CodeBlock>

If we save and rebuild our Site, yellow boxes showing editable regions will appear around the title and author fields in the Visual Editor, enabling inline editing of those values.

<comp.DocShot docshot_key="" alt="" title=""/>

## Markdown content

Editing the body of a content file in the Visual Editor is the most intuitive editing experience for CloudCannon users. Let's add a Text Editable to our content.

In the blog layout, the `<slot />` element is populated by the Markdown content in the main body of each blog file. However, because `<slot />` is not a DOM element, we can't add the `data-editable=""` and `data-prop=""` attributes directly. To get around this issue, we can wrap the `<slot />` element in a `<text-editable>` web component, which can take attributes.

The `<text-editable>` component replaces the need for the `data-editable="text"` attribute, telling CloudCannon what type of data we are editing. But, what is the value of the `data-prop=""` attribute? There are no front matter keys we can reference to tell CloudCannon where the data is stored.

In this case, we can use the special value `@content` to specify Markdown content in the body of a content file.

Here's what our blog layout code should look like:

<comp.CodeBlock language="Astro" source="BlogPost.astro">
``````````

<text-editable data-prop="@content"> /*1*/
    <slot />
</text-editable>

``````````
<comp.Annotation number="1">
  The `<slot />` element is wrapped in the `<text-editable>` web component, which can take Editable attributes. The `data-prop` attribute defines the path to the data property you want to edit and passes that value to the CloudCannon Editable. In this case, we are editing the content of the file outside of the front matter, signified by the special value `@content`.
</comp.Annotation>
</comp.CodeBlock>

If we save and rebuild our Site, a yellow box showing an editable region will appear around the blog content in the Visual Editor, enabling inline editing.

<comp.DocShot docshot_key="" alt="" title=""/>

## Images in your front matter

You can also add an Image Editable to images, allowing users to upload a new image in the Visual Editor.

In this example, each blog file references an image path under the `heroImage` key, which populates the `<img>` tag in the blog layout (`src` is set to `{heroImage}`). To allow CloudCannon to re-render this image in the Visual Editor and let users select a new image, we need to add the `data-editable=""` and `data-prop-src=""` attributes to the `<img>` tag in the blog layout.

The value for `data-editable` should be `image`, as an image path is the type of data stored under the `heroImage` key. We could also wrap the `<img>` element in the equivalent web component `<image-editables>`, however that is not as efficient as adding attributes to existing elements.

Next we'll add `data-prop-src`. The `data-prop-src` attribute is an extension of the `data-prop` attribute. Both define the location of the data property you want to edit. However, `data-prop` only passes the value stored at that location to the Editable (e.g., `/example.jpg`), while `data-prop-src` also renames the value with the `src` key (e.g., `src: /example.jpg`).

CloudCannon Image Editables expect data in the `src: string` format. By adding the add the `data-prop-src="heroImage"` attribute to the `<img>` tag, we can take the value of the `heroImage` key in the front matter, append the key `src`, adn pass it to our Image Editable (we'll dive deeper into the `data-prop` attribute in the [Advanced data property paths]() step of this guide).

Here's what our blog layout code should look like:

<comp.CodeBlock language="Astro" source="BlogPost.astro">
``````````

<div class="hero-image">
    {heroImage &&
      <img
        data-editable="image" /*1*/
        data-prop-src="heroImage" /*2*/
        width={1020}
        height={510}
        src={heroImage}
        alt=""
      />
    }
</div>

``````````
<comp.Annotation number="1">
  The `data-editable` attribute defines what kind of data this element contains. In this case, the value is `image`.
</comp.Annotation>
<comp.Annotation number="2">
  The `data-prop-src` attribute defines the path to the data property you want to edit and passes that value to the CloudCannon Editable with the `src` key. In this case, we are editing the value of the `heroImage` key in the file front matter.
</comp.Annotation>
</comp.CodeBlock>

If we save and rebuild our Site, a yellow box showing an editable region will appear around the blog image in the Visual Editor.

<comp.DocShot docshot_key="" alt="" title=""/>

When you click into the image editable region, CloudCannon will open your computer's file browser and allow you to upload an image. CloudCannon will upload the new image to the location defined by `options.paths.uploads` if you have configured an Image input for your front matter key, or the location defined by `paths.uploads` in the root of your CloudCannon Configuration file. If you have not configured an upload path for your Site, CloudCannon will upload the new image to the uploads folder in the root of your repository, or create one if the folder does not exist.

<comp.Notice info_type="important">
  <p>If you nest an Image Editable inside a Text or Source Editable, CloudCannon will display a misconfigured warning.</p>
</comp.Notice>

In the next step of this guide, we'll cover how to edit webpages generated from HTML-like files by adding a Source Editable.