---
_schema: default
_uuid: 9cfb6628-42ff-4598-9556-9722d672d0a9
_created_at: 2025-08-26T11:26:57+12:00
title: Editing content files
nav_title: Editing content files
order: 3
published: true
start_nav_group:
image: >-
  https://cc-dam.imgix.net/documentation/images/guides/getting-started/guide-thumbnails/CloudCannon-Getting-Started-Thumbnail-Universal.png
description: >-
  Learn how to configure CloudCannon Editables for your content files, including
  YAML front matter and Markdown content.
---
Most content files are hybrid files, with a YAML front matter section containing file information in structured data keys (e.g., `title`, `publish_date`, `author`, etc.) and the main body of content in Markdown. The structured data and content from each file populate fields in a layout file containing the HTML-like templating to generate the output page during a Site build.

Let's take a look at an example. Even though this example is for the SSG Astro, most SSGs that CloudCannon supports will use a similar model (i.e., populating a layout file with values from each content file to generate a page).

This file is a blog post, containing structured data keys for `title`, `description`, `pubDate`, and `heroImage` in the front matter, and Markdown content in the body of the file.

<comp.CodeBlock language=".mdx" source="first-post.mdx">
``````````

---
title: 'First post'
description: 'Lorem ipsum dolor sit amet'
pubDate: 'Jul 08 2022'
heroImage: '../../assets/blog-placeholder-3.jpg'
---

Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Vitae ultricies leo integer malesuada nunc vel risus commodo viverra.

``````````
</comp.CodeBlock>

This file is the blog layout, containing templating for the values of each blog file.

<comp.CodeBlock language="Astro" source="BlogPost.astro">
``````````

---
import { Image } from 'astro:assets';
import type { CollectionEntry } from 'astro:content';
import BaseHead from '../components/BaseHead.astro';
import Footer from '../components/Footer.astro';
import FormattedDate from '../components/FormattedDate.astro';
import Header from '../components/Header.astro';

type Props = CollectionEntry<'blog'>['data'];

const { title, description, pubDate, updatedDate, heroImage } = Astro.props;
---

<html lang="en">
	<body>
		<Header />
		<main>
			<article>
				<div class="hero-image">
                    {heroImage &&
                        <img /*1*/
                          width={1020}
                          height={510}
                          src={heroImage}
                          alt=""
                        />
                      }
				</div>
				<div class="prose">
					<div class="title">
						<div class="date">
							<FormattedDate date={pubDate} /> /*2*/
							{
								updatedDate && (
									<div class="last-updated-on">
										Last updated on <FormattedDate date={updatedDate} />
									</div>
								)
							}
						</div>
						<h1>{title}</h1> /*3*/
						<hr />
					</div>
					<slot /> /*4*/
				</div>
			</article>
		</main>
		<Footer />
	</body>
</html>

``````````
<comp.Annotation number="1">
  This `<img>` element contains image width, height, source, and alt text attributes. The `src` attribute is set to the template `{heroImage}`, which draws its value from the `heroImage` key in the front matter of a blog file.
</comp.Annotation>
<comp.Annotation number="2">
  This `<FormattedDate>` element contains a date attribute, set to the template `{pubDate}`. This value comes from the `pubDate` key in the front matter of a blog file.
</comp.Annotation>
<comp.Annotation number="3">
  This `<h1>` element surrounds the template value `{title}`. This value comes from the `title` key in the front matter of a blog file.
</comp.Annotation>
<comp.Annotation number="4">
  This `<slot />` element marks where the markup content from a blog file will go.
</comp.Annotation>
</comp.CodeBlock>

Together, these files output a webpage that looks like this:

<comp.DocsImage path="" alt="" title=""/>

When you open a content file like `first-post.mdx` in the Visual Editor, CloudCannon will automatically add Inputs to the sidebar for you to edit the structured data in your front matter, but you can't change your content or edit directly on the page. Let's fix that by adding CloudCannon Editables to your blog layout file.

<comp.DocShot docshot_key="" alt="" title=""/>

## Text data in your front matter

In our example, there are three types of structured data....

This file is the blog layout, containing templating for the values of each blog file.

<comp.CodeBlock language="Astro" source="BlogPost.astro">
``````````

<h1>{title}</h1> /*1*/

``````````
<comp.Annotation number="1">
  This `<img>` element contains image width, height, source, and alt text attributes. The `src` attribute is set to the template `{heroImage}`, which draws its value from the `heroImage` key in the front matter of a blog file.
</comp.Annotation>
</comp.CodeBlock>

Together, these files output a webpage that looks like this:

## Images in front matter

x

This file is the blog layout, containing templating for the values of each blog file.

<comp.CodeBlock language="Astro" source="BlogPost.astro">
``````````

<div class="hero-image">
    {heroImage &&
      <img
        data-editable="image" /*1*/
        data-prop-src="heroImage" /*2*/
        width={1020}
        height={510}
        src={heroImage}
        alt=""
      />
    }
</div>

``````````
<comp.Annotation number="1">
  The `data-editable` attribute defines what kind of data
</comp.Annotation>
<comp.Annotation number="2">
  This `data-prop-src` attribute
</comp.Annotation>
</comp.CodeBlock>

## Date data in your front matter

In our example, there are three types of structured data....

This file is the blog layout, containing templating for the values of each blog file.

<comp.CodeBlock language="Astro" source="BlogPost.astro">
``````````

<div class="date">
    <FormattedDate date={pubDate} /> /*1*/
    {
        updatedDate && (
            <div class="last-updated-on">
                Last updated on <FormattedDate date={updatedDate} />
            </div>
        )
    }
</div>

``````````
<comp.Annotation number="1">
  This `<img>` element contains image width, height, source, and alt text attributes. The `src` attribute is set to the template `{heroImage}`, which draws its value from the `heroImage` key in the front matter of a blog file.
</comp.Annotation>
</comp.CodeBlock>

Together, these files output a webpage that looks like this:

## Markdown content

x

<comp.CodeBlock language="Astro" source="BlogPost.astro">
``````````

<slot /> /*1*/

``````````
<comp.Annotation number="1">
  This `<img>` element contains image width, height, source, and alt text attributes. The `src` attribute is set to the template `{heroImage}`, which draws its value from the `heroImage` key in the front matter of a blog file.
</comp.Annotation>
<comp.Annotation number="2">
  This `<FormattedDate>` element contains a date attribute, set to the template `{pubDate}`. This value comes from the `pubDate` key in the front matter of a blog file.
</comp.Annotation>
<comp.Annotation number="3">
  This `<h1>` element surrounds the template value `{title}`. This value comes from the `title` key in the front matter of a blog file.
</comp.Annotation>
<comp.Annotation number="4">
  This `<slot />` element marks where the markup content from a blog file will go.
</comp.Annotation>
</comp.CodeBlock>

&nbsp;

In your Astro component that displays this content:

<comp.CodeBlock language="">
``````````

---
// src/pages/blog/[slug].astro or src/layouts/BlogPost.astro
const { frontmatter } = Astro.props;
---

<html>
<head>
  <title>{frontmatter.title}</title>
</head>
<body>
  <!-- Make the title editable -->
  <h1>
    <text-editable data-prop="title">{frontmatter.title}</text-editable>
  </h1>

  <!-- Make the description editable -->
  <p>
    <text-editable data-prop="description" data-type="text">
      {frontmatter.description}
    </text-editable>
  </p>

  <!-- Make the author editable -->
  <p>By: <text-editable data-prop="author">{frontmatter.author}</text-editable></p>

  <!-- The content becomes editable automatically -->
  <div>
    <text-editable data-prop="@content">
      <slot />
    </text-editable>
  </div>
</body>
</html>

``````````
</comp.CodeBlock>

&nbsp;

```astro

```

### Alternative: Using Data Attributes

If you prefer not to use custom elements, you can use data attributes:

<comp.CodeBlock language="">
``````````

<h1 data-editable="text" data-prop="title">{frontmatter.title}</h1>
<p data-editable="text" data-prop="description" data-type="text">
  {frontmatter.description}
</p>
<p>By: <span data-editable="text" data-prop="author">{frontmatter.author}</span></p>
<div data-editable="text" data-prop="@content">
  <slot />
</div>

``````````
</comp.CodeBlock>

```astro

```