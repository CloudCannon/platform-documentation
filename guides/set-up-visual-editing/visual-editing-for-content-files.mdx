---
_schema: default
_uuid: 9cfb6628-42ff-4598-9556-9722d672d0a9
_created_at: 2025-08-26T11:26:57+12:00
title: Visual editing for content files
nav_title: Visual editing for content files
order: 4
published: true
start_nav_group:
image: >-
  https://cc-dam.imgix.net/documentation/images/guides/getting-started/guide-thumbnails/CloudCannon-Getting-Started-Thumbnail-Universal.png
description: >-
  Learn how to configure Editable Regions for your content files, including YAML
  front matter and Markdown content.
---
The majority of the files on your website are likely to be content files. These are files with a repeated format, stored in *Collections* on your *Site*.

You and any content creators on your team probably spend the majority of your time editing content files, such as when writing a new blog or updating a product, so it's essential to have an intuitive editing interface. Therefore, content files are an excellent starting point for configuring visual editing.

In this step of the guide, we'll cover how to add *Editable Regions* for text and images stored in your front matter and Markdown content.

## What is a content file?

A content file is a hybrid file that contains structured data keys (e.g., `title`, `publish_date`, `author`) in a YAML front matter section and Markdown content in the main body of the file. The structured data and content from each file populate fields in a layout file, which contains the HTML-like templating, generating an output page for each file during the *Site* build.

Let's take a look at an example.

This file is a blog post, containing structured data keys for `title`, `description`, `author`, `pubDate`, and `heroImage` in the front matter, and Markdown content in the body of the file.

<comp.CodeBlock language="markdown" source="first-post.mdx">
``````````

---
title: 'First post'
description: 'Lorem ipsum dolor sit amet'
author: 'C. Kent'
pubDate: 'Jul 10 2025'
heroImage: '../../assets/blog-placeholder-3.jpg'
---

Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Vitae ultricies leo integer malesuada nunc vel risus commodo viverra.

``````````
</comp.CodeBlock>

This file is the blog layout, containing HTML layout for the blog webpage and templating to populate elements with the values from each blog file.

<comp.CodeBlock language="HTML" source="BlogPost.html">
``````````

<html lang="en">
	<body>
		<Header />
		<main>
			<article>
				<div class="hero-image">
                    {heroImage &&
                        <img /*1*/
                          width={1020}
                          height={510}
                          src={heroImage}
                          alt=""
                        />
                      }
				</div>
				<div class="prose">
					<div class="title">
						<div class="date">
							<FormattedDate date={pubDate} />
						</div>
						<h1>{title}</h1> /*2*/
                        <p>By: {author}</p> /*3*/
						<hr />
					</div>
					<slot /> /*4*/
				</div>
			</article>
		</main>
		<Footer />
	</body>
</html>

``````````
<comp.Annotation number="1">
  This `<img>` element contains image width, height, source, and alt text attributes. The `src` attribute is set to the template `{heroImage}`, which draws its value from the `heroImage` key in the front matter of a blog file.
</comp.Annotation>
<comp.Annotation number="2">
  This `<h1>` element surrounds the template value `{title}`. This value comes from the `title` key in the front matter of a blog file.
</comp.Annotation>
<comp.Annotation number="3">
  This `<p>` element surrounds the template value `{author}`, prepended by the plain text "By:". This value comes from the `author` key in the front matter of a blog file.
</comp.Annotation>
<comp.Annotation number="4">
  This `<slot />` element marks where the markup content from a blog file will go.
</comp.Annotation>
</comp.CodeBlock>

<comp.Notice info_type="info">
  <p>Some SSGs use specific file types rather than <code>.html</code> for the layout pages (e.g., Astro uses <code>.astro</code> files). You can still add <em>Editable Regions</em> to these files as long as they output to an HTML file after a <em>Site</em> build.</p>
</comp.Notice>

Together, these files output a webpage that looks like this:

<comp.DocsImage path="" alt="" title=""/>

## Text in your front matter

In our example above, each blog file contains two text front matter keys we want to edit inline: `title` and `author`. We can add Text *Editable Regions* to the blog layout file to enable this.

When building your *Site*, CloudCannon populates the templating inside the blog layout file with values from each blog file to create a series of output HTML pages. Specifically, the `title` key in the front matter of each blog file populates the `[title]` templating field inside the `<h1>` tag, and the `author` key populates the `[author]` templating field inside the `<p>` tag.

Let's start with `title`.

Inside the `<h1>` tag, we can add the `data-editable` HTML attribute with the value `text`, to define a Text *Editable Region*. We also need to add the `data-prop` HTML attribute to the `<h1>` tag, to define the path the to data property we want to edit (we'll dive deeper into paths for the `data-prop` attribute in the [Advanced data property paths](/documentation/guides/configure-visual-editing/advanced-data-property-paths/) step of this guide). CloudCannon will pass that value to the *Editable Region* in the Visual Editor and re-render the field. In this example, the value of `data-prop` should be `title`, as this is the name of the front matter key.

Here's what our blog layout code should look like:

<comp.CodeBlock language="HTML" source="BlogPost.html">
``````````

<h1 data-editable="text" data-prop="title" >{title}</h1> /*1*/

``````````
<comp.Annotation number="1">
  The `data-editable` attribute defines what kind of data this element contains. In this case, the value is `text`. The `data-prop` attribute defines where data is stored. In this case, we are editing the value of the `title` key in the file front matter.
</comp.Annotation>
</comp.CodeBlock>

Editing the value of `author` in the Visual Editor is slightly more complicated.

Just like the `title` example, we need to define the type of *Editable Region* we want and the path to the proerty we want to edit.But, the `[author]` templating field is not the only value inside the `<p>` tag: the plain text "By:" prepends the author value. If we added `<p data-editable="text" data-prop="author">` to the `<p>` tag in our blog layout, the Visual Editor would re-render the field to only show the value of `author`, hiding the plain text.

It is important to note that *Editable Regions* don't modify the code of your templating, so the "By:" plain text is not destroyed. Instead, they update the value of the front matter key and re-render the webpage preview. This leads to a mismatch in the appearance of the built *Site*, which includes "By:" before the author name, and the preview in the Visual Editor, which would not.

To avoid this issue, we can use the web component `<editable-text>` instead. The `<text-editable>` web component replaces the need for the `data-editable="text"` attribute, telling CloudCannon what type of data we are editing. This is useful if you want to edit an element that can't take attributes, or a specific section of a string.

We can add the `data-prop="author"` attribute to this web component.

Here's what our blog layout code should look like:

<comp.CodeBlock language="HTML" source="BlogPost.html">
``````````

<p>By: <text-editable data-prop="author">{author}</text-editable></p> /*1*/

``````````
<comp.Annotation number="1">
  The `<text-editable>` web component defines what kind of data this element contains and takes other Editable attributes. The `data-prop` attribute defines the path to the data property you want to edit and passes that value to the CloudCannon Editable. In this case, we are editing the value of the `title` key in the file front matter.
</comp.Annotation>
</comp.CodeBlock>

Once we save and rebuild our *Site*, CloudCannon will show yellow boxes around the title and author fields on the webpage, indicating *Editable Regions* in the Visual Editor.

<comp.DocShot docshot_key="" alt="" title="" type="screenshot"/>

## Markdown content

In our example, the Markdown content in each blog file populates the `<slot />` element in the blog layout file at build time. We want to edit the Markdown content directly on the page, as well as format the rich text. However, because `<slot />` is not a DOM element, we can't add the `data-editable=""` and `data-prop=""` attributes directly.

Just like the `author` example above, we can wrap the `<slot />` element in a `<text-editable>` web component, which can take attributes.

The `<text-editable>` component replaces the need for the `data-editable="text"` attribute, telling CloudCannon what type of data we are editing. But, what is the value of the `data-prop=""` attribute? There are no front matter keys we can reference to tell CloudCannon where the data is stored.

In this case, we can use the special value `@content` to specify Markdown content in the body of a content file.

Here's what our blog layout code should look like:

<comp.CodeBlock language="Astro" source="BlogPost.astro">
``````````

<text-editable data-prop="@content"> /*1*/
    <slot />
</text-editable>

``````````
<comp.Annotation number="1">
  The `<slot />` element is wrapped in the `<text-editable>` web component, which can take Editable attributes. The `data-prop` attribute defines the path to the data property you want to edit and passes that value to the CloudCannon Editable. In this case, we are editing the content of the file outside of the front matter, signified by the special value `@content`.
</comp.Annotation>
</comp.CodeBlock>

Once we save and rebuild our *Site*, CloudCannon will show a yellow *Editable Region* box around the content on the webpage. When you click into the *Editable Region*, CloudCannon will also display a WYSIWYG toolbar for formatting your content.

### Types of editable text

Why did the Visual Editor show a WYSIWYG toolbar for the content of our blog files, but not for the title or author?

* `data-type` - Element type for editing behavior
  * `"span"` - Inline text editing (default for `<text-editable>`)
  * `"text"` - Paragraph-level text editing
  * `"block"` - Full rich-text editing with multiple paragraphs

&nbsp;

&nbsp;

&nbsp;

---

When you open a content file like `first-post.mdx` in the Visual Editor, CloudCannon will automatically add Inputs to the sidebar for you to edit the structured data in your front matter, but you can't change your content or edit it directly on the page.

<comp.DocShot docshot_key="" alt="" title=""/>

Let's fix that by adding Text and Image Editables to your blog layout file.

In this step of the guide, we'll add the following components and attributes:

* `data-editable="text"` and `<text-editable>` — This attribute, and its equivalent web component, defines the data type inside an Editable as `text`.
* `data-editable="image"` and `<image-editable>` — This attribute, and its equivalent web component, defines the data type inside an Editable as `image`.
* `data-prop=""` — This attribute defines the path to the data property you want to edit and passes that value to the CloudCannon Editable.
* `data-prop-src=""` — This attribute defines the path to the data property you want to edit and passes that value to the CloudCannon Editable with the `src` key.

For a complete list of configuration options for CloudCannon Editables, please read our [Editables reference](/documentation/articles/editables-reference) documentation.

##

&nbsp;

## Markdown content

&nbsp;

<comp.DocShot docshot_key="" alt="" title=""/>

## Images in your front matter

You can also add an Image Editable to images, allowing users to upload a new image in the Visual Editor.

In this example, each blog file references an image path under the `heroImage` key, which populates the `<img>` tag in the blog layout (`src` is set to `<span data-cms-snippet-type="inline" data-cms-snippet-id="f40b9b50-6101-4182-8079-dee78f22b574" data-cms-snippet-data="eyJ0ZW1wbGF0ZSI6Imhlcm9JbWFnZSIsIl9oaWRkZW4iOnRydWUsIl9zbmlwcGV0X3R5cGUiOiJfY2NfbWR4X3Vua25vd25fdGVtcGxhdGUiLCJfbWV0YSI6eyJ0ZW1wbGF0ZSI6eyJvcmlnaW5hbERhdGEiOlt7Il90eXBlIjoidGV4dCIsInRleHQiOiJoZXJvSW1hZ2UifV19fX0="></span>`). To allow CloudCannon to re-render this image in the Visual Editor and let users select a new image, we need to add the `data-editable=""` and `data-prop-src=""` attributes to the `<img>` tag in the blog layout.

The value for `data-editable` should be `image`, as an image path is the type of data stored under the `heroImage` key. We could also wrap the `<img>` element in the equivalent web component `<image-editables>`, however that is not as efficient as adding attributes to existing elements.

Next we'll add `data-prop-src`. The `data-prop-src` attribute is an extension of the `data-prop` attribute. Both define the location of the data property you want to edit. However, `data-prop` only passes the value stored at that location to the Editable (e.g., `/example.jpg`), while `data-prop-src` also renames the value with the `src` key (e.g., `src: /example.jpg`).

CloudCannon Image Editables expect data in the `src: string` format. By adding the add the `data-prop-src="heroImage"` attribute to the `<img>` tag, we can take the value of the `heroImage` key in the front matter, append the key `src`, adn pass it to our Image Editable (we'll dive deeper into the `data-prop` attribute in the [Advanced data property paths](/documentation/guides/configure-visual-editing/advanced-data-property-paths/) step of this guide).

Here's what our blog layout code should look like:

<comp.CodeBlock language="Astro" source="BlogPost.astro">
``````````

<div class="hero-image">
    {heroImage &&
      <img
        data-editable="image" /*1*/
        data-prop-src="heroImage" /*2*/
        width={1020}
        height={510}
        src={heroImage}
        alt=""
      />
    }
</div>

``````````
<comp.Annotation number="1">
  The `data-editable` attribute defines what kind of data this element contains. In this case, the value is `image`.
</comp.Annotation>
<comp.Annotation number="2">
  The `data-prop-src` attribute defines the path to the data property you want to edit and passes that value to the CloudCannon Editable with the `src` key. In this case, we are editing the value of the `heroImage` key in the file front matter.
</comp.Annotation>
</comp.CodeBlock>

If we save and rebuild our Site, a yellow box showing an editable region will appear around the blog image in the Visual Editor.

<comp.DocShot docshot_key="" alt="" title=""/>

When you click into the image editable region, CloudCannon will open your computer's file browser and allow you to upload an image. CloudCannon will upload the new image to the location defined by `options.paths.uploads` if you have configured an Image input for your front matter key, or the location defined by `paths.uploads` in the root of your CloudCannon Configuration file. If you have not configured an upload path for your Site, CloudCannon will upload the new image to the uploads folder in the root of your repository, or create one if the folder does not exist.

<comp.Notice info_type="important">
  <p>If you nest an Image Editable inside a Text or Source Editable, CloudCannon will display a misconfigured warning.</p>
</comp.Notice>

In the next step of this guide, we'll cover how to edit webpages generated from HTML-like files by adding a Source Editable.