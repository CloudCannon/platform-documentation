---
_schema: default
_uuid: 5095ec21-834a-40b8-9a29-73f4eb99cab0
_created_at: 2025-08-28T08:53:07+12:00
title: Visual editing for arrays and page building
nav_title: 'TODO: Visual editing for arrays and page building'
order: 6
published: true
start_nav_group:
image: >-
  https://cc-dam.imgix.net/documentation/images/guides/getting-started/guide-thumbnails/CloudCannon-Getting-Started-Thumbnail-Universal.png
description: >-
  Learn how to configure Editable Regions for arrays, allowing you to add,
  delete, and reorder items, or enable page building.
---
Some webpages, or webpage components, are constructed from arrays. An array could be simple, where each item has the same structure (e.g., a testimonial component), or more complex, where each item has a different structure (e.g., a page with various components).

You can enable your team to visually edit arrays, including adding, deleting, and reordering items.

In this step of the guide, we'll cover how to add *Editable Regions* to simple arrays and enable page building with editable complex arrays.

## What are arrays?

x

## Simple arrays

**This file is a blog post, containing structured data keys for `title`, `description`, `author`, `pubDate`, and `heroImage` in the front matter, and Markdown content in the body of the file.**

&nbsp;

Our testimonial page is generated by an HTML layout, populated by several data files containing testimonial content.

This file is a testimonial data file, containing structured data keys for `image`, `image_alt`, `author`, `job_title`, and `quote`.

<comp.CodeBlock language="YAML" source="pete-fish.yml">
``````````

image: /images/testimonial/logo-2.jpg //2
image_alt: Profile photo of Pete Fish
author: Pete Fish
job_title: CMO at Clear Appeal
quote: >-
Sendit has taken Clear Appeal to the next level with its beautiful
targeted email campaigns.

``````````
</comp.CodeBlock>

This file is the testimonial page layout, containing HTML webpage and templating to populate elements with the values from each testimonial file.

&nbsp;

This file is a blog post, containing structured data keys for `title`, `description`, `author`, `pubDate`, and `heroImage` in the front matter, and Markdown content in the body of the file.

<comp.CodeBlock language="markdown" source="first-post.mdx">
``````````

---
title: 'First post'
description: 'Lorem ipsum dolor sit amet'
author: 'C. Kent'
pubDate: 'Jul 10 2025'
heroImage: '../../assets/blog-banner.jpg'
heroImageTitle: 'Curabitur imperdiet diam sit amet.'
heroImageAlt: 'Nunc gravida ullamcorper mi, ac.'
---

Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Vitae ultricies leo integer malesuada nunc vel risus commodo viverra.

``````````
</comp.CodeBlock>

This file is the blog layout, containing HTML layout for the blog webpage and templating to populate elements with the values from each blog file.

<comp.CodeBlock language="HTML" source="BlogPost.html">
``````````

<html lang="en">
	<body>
		<Header />
		<main>
			<article>
				<div class="hero-image">
                    {heroImage &&
                        <img
                          width={1020}
                          height={510}
                          src={heroImage}
                          title={heroImageTitle}
                          alt={heroImageAlt}
                        /> <!--1-->
                      }
				</div>
				<div class="prose">
					<div class="title">
						<div class="date">
							<FormattedDate date={pubDate} />
						</div>
						<h1>{title}</h1> <!--2-->
                        <p>By: {author}</p> <!--3-->
						<hr />
					</div>
					<slot /> <!--4-->
				</div>
			</article>
		</main>
		<Footer />
	</body>
</html>

``````````
<comp.Annotation number="1">
  This `<img>` element contains image width, height, source, title, and alt text attributes. The `src`, `title`, and `alt` attributes are set to the template `{heroImage}`, `{heroImageTitle}`, and `{heroImageAlt}` respectively, which draw their values from the keys in the front matter of a blog file.
</comp.Annotation>
<comp.Annotation number="2">
  This `<h1>` element surrounds the template value `{title}`. This value comes from the `title` key in the front matter of a blog file.
</comp.Annotation>
<comp.Annotation number="3">
  This `<p>` element surrounds the template value `{author}`, prepended by the plain text "By:". This value comes from the `author` key in the front matter of a blog file.
</comp.Annotation>
<comp.Annotation number="4">
  This `<slot />` element marks where the markup content from a blog file will go.
</comp.Annotation>
</comp.CodeBlock>

<comp.Notice info_type="info">
  <p>Some SSGs use specific file types rather than <code>.html</code> for the layout pages (e.g., Astro uses <code>.astro</code> files). You can still add <em>Editable Regions</em> to these files as long as they output to an HTML file after a <em>Site</em> build.</p>
</comp.Notice>

Together, these files output a webpage that looks like this:

<comp.CodeBlock language="YAML" source="pete-fish.yml">
``````````

image: /images/testimonial/logo-2.jpg //2
image_alt: Profile photo of Pete Fish
author: Pete Fish
job_title: CMO at Clear Appeal
quote: >-
Sendit has taken Clear Appeal to the next level with its beautiful
targeted email campaigns.

``````````
</comp.CodeBlock>

This file is our testimonials page

&nbsp;

---

&nbsp;

We can use Array Editables to allow users to click and drag elements around the Visual Editor, reordering them within an array.

In this step of the guide, we'll add the following attributes:

* `data-editable="array"` and `<array-editable>` — This attribute, and its equivalent web component, defines the data type inside an Editable as `array`.
* `data-editable="array-item"` and `<array-item>` — This attribute, and its equivalent web component, defines the data type inside an Editable as `array-item`.
* `data-prop=""` — This attribute defines the path to the data property you want to edit and passes that value to the CloudCannon Editable.
* `data-id-key=""` — This attribute defines...
* `data-id` — This attribute defines...

For a complete list of configuration options for CloudCannon Editables, please read our [Editables reference](/documentation/articles/editables-reference) documentation.

## Simple arrays

&nbsp;

Let's walk through an example.

Our Home page, `index.mdx`, stores testimonial information in YAML in the `slider` array. Each item in the array has the same structure, with the `image`, `image_alt`, `author`, `designation`, and `message` keys.

<comp.CodeBlock language="YAML" source="index.yml">
``````````

content_blocks:
  component_name: testimonial
    title: Build relationships that last
    description: >-
      Customers from around the world are building game-changing email marketing campaigns.
    slider: /*1*/
      - image: /images/testimonial/logo-2.jpg //2
        image_alt: Profile photo of Pete Fish
        author: Pete Fish
        designation: CMO at Clear Appeal
        message: >-
          Sendit has taken Clear Appeal to the next level with its beautiful
          targeted email campaigns.
      - image: /images/testimonial/logo-3.jpg #3
        image_alt: Profile photo of Dolly Watson
        author: Dolly Watson
        designation: Digital Marketer at Time Cop
        message: >-
          Wow, what a difference Sendit has made. My customers are more engaged
          than ever.
      - image: /images/testimonial/logo-4.jpg <!--4-->
        image_alt: Profile photo of Simon Moriarty
        author: Simon Moriarty
        designation: Head of Marketing at Pinnacle Mines
        message___5___: >-
          I can't imagine life without Sendit now, I have no idea how we were
          surviving before.

``````````
</comp.CodeBlock>

Data from structured data keys in `index.mdx` populate templating in our layout file

<comp.CodeBlock language="JSX" source="testimonials.jsx">
``````````

import MarkdownIt from "markdown-it";
const md = new MarkdownIt({ html: true });

export default function GlobalTestimonial(block) {
  return (
    <section>
      <div>
        <div>
          <div>
            <div>
              <h2>
                {block.title}
              </h2>
              <div>
                {block.title}
              </div>
            </div>
          </div>
        </div>
        <div data-editable="array" data-prop="slider"> /*1*/
          {block.slider.map((slide, i) => (
            <Testimonial slide={slide} i={i} key={i} />
          ))}
        </div>
      </div>
    </section>
  );
}
function Testimonial({ slide, i }) {
  return (
    <div key={i} data-editable="array-item">
      <div>
        <div>
          <div>
            <img
              src={slide.image}
              alt="logo"
              className={slide.image_alt}
              loading="lazy"
            />
          </div>
          <div>
            <h3>{slide.author}</h3>
            <p>{slide.designation}</p>
          </div>
        </div>
        <p>{slide.message}</p>
      </div>
    </div>
  );
}

``````````
</comp.CodeBlock>

Together, these files output a webpage that looks like this:

<comp.DocsImage path="" alt="" title=""/>

Let's enable array editing in the Visual Editor by adding Array Editables to our component file.

&nbsp;

&nbsp;

&nbsp;

&nbsp;

&nbsp;

**When you open a content file like `first-post.mdx` in the Visual Editor, CloudCannon will automatically add Inputs to the sidebar for you to edit the structured data in your front matter, but you can't change your content or edit it directly on the page.**

**Let's fix that by adding CloudCannon Editables to your blog layout file.**

&nbsp;

## Complex arrays and page building

x

&nbsp;

&nbsp;

---

## Step 3: Make Arrays Editable

If your frontmatter has arrays (like tags or a team list):

```markdown
---
title: "About Us"
team_members:
  - name: "John Doe"
    role: "Developer"
    bio: "Loves coding"
  - name: "Jane Smith"
    role: "Designer"
    bio: "Creative problem solver"
tags: ["astro", "web-development", "javascript"]
---
```

Make them editable in your Astro component:

```astro
---
const { frontmatter } = Astro.props;
---

<!-- Editable team members array -->
<section>
  <h2>Our Team</h2>
  <array-editable data-prop="team_members">
    {frontmatter.team_members?.map((member, index) => (
      <array-item key={index}>
        <div class="team-member">
          <h3><text-editable data-prop="name">{member.name}</text-editable></h3>
          <p><text-editable data-prop="role">{member.role}</text-editable></p>
          <p><text-editable data-prop="bio" data-type="text">{member.bio}</text-editable></p>
        </div>
      </array-item>
    ))}
  </array-editable>
</section>

<!-- Editable simple tags array -->
<div>
  <h3>Tags:</h3>
  <array-editable data-prop="tags">
    {frontmatter.tags?.map((tag, index) => (
      <array-item key={index}>
        <span class="tag">
          <text-editable data-prop="">{tag}</text-editable>
        </span>
      </array-item>
    ))}
  </array-editable>
</div>
```

Step 6: Working with Collections#

If you're using Astro's content collections, you can make collection data editable:

```astro
---
import { getCollection } from 'astro:content';
const posts = await getCollection('blog');
---

<h1>Blog Posts</h1>
<array-editable data-prop="@collections[blog]">
  {posts.map((post) => (
    <array-item key={post.id}>
      <article>
        <h2>
          <text-editable data-prop="data.title">{post.data.title}</text-editable>
        </h2>
        <p>
          <text-editable data-prop="data.description">{post.data.description}</text-editable>
        </p>
        <a href={`/blog/${post.slug}/`}>Read more</a>
      </article>
    </array-item>
  ))}
</array-editable>
```