---
_uuid: "b04875a8-1b36-47d1-b4fa-0617c89be522"
_created_at: "2022-10-27 02:00:59 +0000"
title: "Snippets Reference"
nav_title: "Snippets Reference"
published: true
image: "/documentation/static/CloudCannonDocumentationog.jpg"
description: "The full set of options available when configuring low-level snippets for CloudCannon."
tags: ["content editor","snippets"]
related_articles: ["/articles/introducing-the-content-editor"]
related_links: null
---

In some cases, you might want to configure a snippet that is more complicated than the snippet templates provided for your SSG allow.
Alternatively, you might be working with a syntax that CloudCannon doesn't provide templates for, and you want to create your own snippet templates.
In these cases, CloudCannon's underlying snippet parser can be configured directly. 

Configuring snippets directly is more complicated than using snippet templates, but unlocks significantly more potential.

## Snippet syntax

Custom snippets are configured under the `_snippets` key, but provide a `snippet` string rather than a `template`. 
If we were wanting to configure a custom snippet that matched bash variables like `$HOME` or `$PATH`, we might use the following config:

<comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
```
_snippets:
  variable:
    snippet___1___: "$[[var_name]]"
    params:
      var_name___2___:
        parser___3___: "argument"
        options___4___:
          model:
            editor_key: variable
          format:
            string_boundary: [""]
```
<comp.Annotation number="1">
  The snippet string contains the text to match for your snippet, with any dynamic sections represented using a placeholder in double square brackets.
  In this example, the `$` will match a literal `$` character, and `[[var_name]]` will use a specified parser.
</comp.Annotation>
<comp.Annotation number="2">
  For each placeholder, a matching key should be supplied inside the `params` object. Here, `[[var_name]]` maps to `params.var_name`.
</comp.Annotation>
<comp.Annotation number="3">
  Each param needs to specify a `parser` from the list of supported parsers. Here, the `argument` parser is used for matching a single value.
</comp.Annotation>
<comp.Annotation number="4">
  Each parser requires a different set of `options`. See the argument parser options for more details on this example.
</comp.Annotation>
</comp.MultiCodeBlock>

## Parsers

These are the parsers that a snippet can use:

<comp.DataReference>
 <comp.DataReferenceRow label="argument" type_markdown="">
   Parses a single argument, optionally delimited by characters. Useful for matching a single positional argument.

   <comp.CodeBlock language="markdown" frameless={true}>
    ```
    {{<figure image.png>}}
              └───────┘
    ```
    </comp.CodeBlock>
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="argument_list" type_markdown="">
   Parses a list of positional arguments based on their position.

   <comp.CodeBlock language="markdown" frameless={true}>
    ```
    {{<figure "image.png" "My image title">}}
              └──────────────────────────┘
    ```
    </comp.CodeBlock>
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="key_values" type_markdown="">
   Parses repeating pairs of keys and values. Useful for most SSG snippets that take properties.

   <comp.CodeBlock language="liquid" frameless={true}>
    ```
    {% include "image.html" image: "tree.png" alt: "Image of a tree" %}
                            └──────────────────────────────────────┘
    ```
    </comp.CodeBlock>
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="content" type_markdown="">
   Parses rich multiline content, such as the content between paired tags. Can be configured to parse nested snippets within.

   <comp.CodeBlock language="liquid" frameless={true}>
    ```
    {% highlight "js" %} let a = b; {% endhighlight %}
                        └──────────┘
    ```
    </comp.CodeBlock>
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="literal" type_markdown="">
   Parses an exact literal value. Mainly useful when configuring a snippet template.
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="repeating_literal" type_markdown="">
   Parses a repeating set of exact literal values. 
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="optional" type_markdown="">
    Higher-order parser that wraps a snippet string and makes it optional
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="repeating" type_markdown="">
    Higher-order parser that wraps a snippet string and allows it to repeat
 </comp.DataReferenceRow>
</comp.DataReference>

### Argument parser

Parses a single argument, optionally delimited by characters. Useful for matching a single positional argument.

<comp.Example>
  To illustrate the argument parser, we'll look at a custom `video` snippet that takes a single named argument:

  <comp.CodeBlock language="markdown" source="page.md">
  ```
  ## My blog post

  <<video CZcNgDN81Sw>>

  Morbi leo risus, porta ac consectetur ac, vestibulum at eros.
  ```
  </comp.CodeBlock>

  <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
  ```
  _snippets:
    video:
      snippet: "<<video [[video_arg]]>>"
      params:
        video_arg:
          parser: "argument"
          options:
            model:
              editor_key: video_id
  ```
  </comp.MultiCodeBlock>
</comp.Example>

#### Model Options
<comp.DataReference>
 <comp.DataReferenceRow label="editor_key" type_markdown="string">
    Specifies the key that a user in CloudCannon will see when editing this value.
    This key will also be used if you want to specify any input configuration using `_inputs`.

    <comp.Example>
      <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
      ```
      parser: "argument"
      options:
        model:
          editor_key: video_id
      ```
      </comp.MultiCodeBlock>

      {/* TODO: Screenshot of data panel */}
    </comp.Example>

 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="allowed_values" type_markdown="array of strings">
   A list of valid values for the parser. If specified, values not in the provided list will cause this snippet to be skipped,
   and a different snippet will be matched if possible. 
   A user entering a different value while editing this snippet will cause it to error, so this option is
   best paired with a select input configured on the `editor_key`.

    <comp.Example>
      <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
      ```
      parser: "argument"
      options:
        model:
          editor_key: video_id
          allowed_values: ["riXoAr6gO-E", "CZcNgDN81Sw", "0iwNjcFIHNM"]
      ```
      </comp.MultiCodeBlock>

      Example usage:

      <comp.CodeBlock language="markdown" source="page.md">
      ```
      ## My blog post

      <<video CZcNgDN81Sw>> <!--1-->

      <<video riXoAr6gO-E>> <!--1-->

      <<video RuvMHkfOpvg>> <!--2-->

      Morbi leo risus, porta ac consectetur ac, vestibulum at eros.
      ```
      <comp.Annotation number="1">
        These IDs match a value in `allowed_values`, thus will be shown as a `video` snippet
      </comp.Annotation>
      <comp.Annotation number="2">
        This ID is not present in `allowed_values` and will not parse as a `video` snippet.
        It may still parse as another snippet, or will remain as plaintext.
      </comp.Annotation>
      </comp.CodeBlock>
    </comp.Example>

 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="default" type_markdown="string">
   The default value for this argument, which is used when adding a new snippet to a page in CloudCannon.

    <comp.Example>
      <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
      ```
      parser: "argument"
      options:
        model:
          editor_key: video_id
          default: "riXoAr6gO-E"
      ```
      </comp.MultiCodeBlock>
    </comp.Example>

    With this config, adding a new `video` snippet to a page in CloudCannon will instantiate it as `<<video riXoAr6gO-E>>`.
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="implied_boolean" type_markdown="boolean">
   If `implied_boolean` is set to `true`, then any value in this argument will alias to `true`, and an empty value will alias
   to `false`.

    <comp.Example>
      <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
      ```
      parser: "argument"
      options:
        model:
          editor_key: has_video_id
          implied_boolean: true
      ```
      </comp.MultiCodeBlock>

      With this config the video ID itself will not be used. The editor will instead see a checkbox named `has_video_id`
      representing the presence of the argument. Unchecking and rechecking this checkbox will result in `<<video true>>`,
      so this option is not very useful for our video snippet example.
    </comp.Example>
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="optional" type_markdown="boolean">
   Whether a value must exist for this parser. Useful for a snippet that takes zero or one positional arguments.

    <comp.Example>
      <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
      ```
      parser: "argument"
      options:
        model:
          editor_key: video_id
          optional: true
      ```
      </comp.MultiCodeBlock>

      With this config, both of the following snippet examples will parse:

      <comp.CodeBlock language="markdown" source="page.md">
      ```
      ## My blog post

      <<video CZcNgDN81Sw>>

      <<video>>

      Morbi leo risus, porta ac consectetur ac, vestibulum at eros.
      ```
      </comp.CodeBlock>
    </comp.Example>

 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="remove_empty" type_markdown="boolean">
   If `true`, the output of this parser will be omitted entirely if the value is empty, rather than saving an empty value such as `""`.
   In most cases, you will want to make sure to set `optional: true` so that the output is able to be parsed again.

    <comp.Example>
      <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
      ```
      parser: "argument"
      options:
        model:
          editor_key: video_id
          remove_empty: true
      ```
      </comp.MultiCodeBlock>

      In cases where you have a string boundary set, with this config saving a snippet with an 
      empty `video_id` value will save it as `<<video>>` rather than `<<video "">>` or `<<video ''>>`.
    </comp.Example>

 </comp.DataReferenceRow>
</comp.DataReference>

#### Format Options

`format` should be an object containing keys from the available Format keys. 

<comp.Example>
  A common option to configure for the
  argument parser is the `string_boundary`:

  <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
  ```
  _snippets:
    video:
      snippet: "<<video [[video_arg]]>>"
      params:
        video_arg:
          parser: "argument"
          options:
            model:
              editor_key: video_id
            format:
              string_boundary: ['"', "'"]
  ```
  </comp.MultiCodeBlock>

  This would make our snippet match `<<video "CZcNgDN81Sw">>` or `<<video 'CZcNgDN81Sw'>>` but not `<<video CZcNgDN81Sw>>`.
</comp.Example>

### Argument List parser

This parser matches a list of positional arguments and parses each using a different model.

Instead of taking a single `model` object, this parser takes an array of `model` objects.
Each `model` object is an [argument parser](#argument-parser), but they all share one `format` object.

<comp.Example>
  Continuing with our `video` snippet shown above, we might add the ability to add a custom title as an optional second positional argument:

  <comp.CodeBlock language="markdown" source="page.md">
  ```
  ## My blog post

  <<video "riXoAr6gO-E">>

  <<video "CZcNgDN81Sw" "Whiteboard the Web and Astro with Ben Holmes">>

  Morbi leo risus, porta ac consectetur ac, vestibulum at eros.
  ```
  </comp.CodeBlock>

  <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
  ```
  _snippets:
    video:
      snippet: "<<video [[arguments]]>>"
      params:
        arguments:
          parser: "argument_list"
          options:
            models: [{ editor_key: "video_id" }, { editor_key: "video_title", optional: true }]
            format: { string_boundary: ['"'] }
  ```
  </comp.MultiCodeBlock>

  <comp.Notice info_type="info">
    Since the title might contain whitespace, we're now setting a string boundary of `"` to capture each argument as intended.
  </comp.Notice>
</comp.Example>

### Content parser

The content parser is used to extract a block of content, optionally spread across multiple lines.

Usually this parser will be used to parse the content between paired start and end tags in a templating language.

<comp.Example>
  To illustrate the content parser, we'll look at a custom `highlight` snippet that wraps a block of content:

  <comp.CodeBlock language="markdown" source="page.md">
  ```
  ## My blog post

  <<highlight>> My highlighted content! <</highlight>>

  Morbi leo risus, porta ac consectetur ac, vestibulum at eros.
  ```
  </comp.CodeBlock>

  <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
  ```
  _snippets:
    highlight:
      snippet: "<<highlight>>[[inner]]<</highlight>>"
      params:
        inner:
          parser: "content"
          options:
            editor_key: highlighted_text
  ```
  </comp.MultiCodeBlock>
</comp.Example>


<comp.DataReference>
 <comp.DataReferenceRow label="editor_key" type_markdown="string">
    Specifies the key that a user in CloudCannon will see when editing this value.
    This key will also be used if you want to specify any input configuration using `_inputs`.

    <comp.Example>
      <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
      ```
      _snippets:
        highlight:
        snippet: "<<highlight>>[[inner]]<</highlight>>"
        params:
          inner:
            parser: "content"
            options:
              editor_key: highlighted_text
        _inputs:
          highlighted_text:
            type: markdown
            comment: Enter the text that should be highlighted
      ```
      </comp.MultiCodeBlock>

      With this config, the inner value of out snippet will be editable in CloudCannon
      using an input named `highlighted_text`, which we have configured as markdown
      and specified a comment for.
    </comp.Example>

 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="indented_by" type_markdown="string">
    A string value that the content parser will require when parsing. 
    Often used when a snippet continues for as long as content is indented.

    If you want parsing to be flexible, but the output to be formatted, use the Style options instead.

    <comp.Example>
      <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
      ```
      _snippets:
        highlight:
          snippet: "<<highlight>>[[inner]]<</highlight>>"
          params:
            inner:
              parser: "content"
              options:
                editor_key: highlighted_text
                indented_by___0___: "  "
      ```
      </comp.MultiCodeBlock>

      Example usage:

      <comp.CodeBlock language="markdown" source="page.md">
      ```
      ## My blog post

      <<highlight>>
        My highlighted content!   <!--1-->
      <</highlight>>

      <<highlight>>
          My highlighted content! <!--2-->
      <</highlight>>

      <<highlight>>
      My highlighted content!     <!--3-->
      <</highlight>>

      Morbi leo risus, porta ac consectetur ac, vestibulum at eros.
      ```
      <comp.Annotation number="1">
        This will parse correctly as `My highlighted content!`
      </comp.Annotation>
      <comp.Annotation number="2">
        This will strip only the indentation that matches, and return `  My highlighted content!`
      </comp.Annotation>
      <comp.Annotation number="2">
        This will **not** match this parser, as indentation is required.
        Use the `style.block.indent` option instead.
      </comp.Annotation>
      </comp.CodeBlock>
    </comp.Example>

 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="allow_leading" type_markdown="boolean">
    If an `indented_by` value is set, `allow_leading: true` signifies that the _first_
    line of the content does **not** need to be indented, but subsequent lines do.

    <comp.Example>
      <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
      ```
      parser: "content"
      options:
         editor_key: highlighted_text
         indented_by: "  "
         allow_leading: true
      ```
      </comp.MultiCodeBlock>

      Example usage:

      <comp.CodeBlock language="markdown" source="page.md">
      ```
      ## My blog post

      <<highlight>>
        My highlighted content!   <!--1-->
      <</highlight>>

      <<highlight>>Some initial content
         More highlighted content!   <!--2-->
      <</highlight>>

      Morbi leo risus, porta ac consectetur ac, vestibulum at eros.
      ```
      <comp.Annotation number="1">
        This will parse correctly as `My highlighted content!`
      </comp.Annotation>
      <comp.Annotation number="2">
        This will also parse correctly, as `Some initial content\nMore highlighted content!`,
        despite the first line not being indented.
      </comp.Annotation>
      </comp.CodeBlock>
    </comp.Example>

 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="trim_text" type_markdown="boolean">
    If true, all whitespace and newlines will be trimmed from the start and end of the content 
    before it is presented to an editor in CloudCannon.


    <comp.Example>
      <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
      ```
      parser: "content"
      options:
         editor_key: highlighted_text
         trim_text: true
      ```
      </comp.MultiCodeBlock>

      Example usage:

      <comp.CodeBlock language="markdown" source="page.md">
      ```
      ## My blog post

      <<highlight>>
        My highlighted content!   <!--1-->
      <</highlight>>

      <<highlight>>  My highlighted content!  <</highlight>> <!--1-->

      Morbi leo risus, porta ac consectetur ac, vestibulum at eros.
      ```
      <comp.Annotation number="1">
        Both of these will parse as `My highlighted content!`, despite the newlines and
        whitespace surrounding them.

        To add whitespace back in when outputting the snippet, use the Style options.
      </comp.Annotation>
      </comp.CodeBlock>
    </comp.Example>

 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="allow_nested" type_markdown="boolean">
    If set, nested snippets will be parsed and returned.

    <comp.Example>
      <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
      ```
      parser: "content"
      options:
         editor_key: highlighted_text
         allow_nested: true
      ```
      </comp.MultiCodeBlock>

      Example usage:

      <comp.CodeBlock language="markdown" source="page.md">
      ```
      ## My blog post

      <<highlight>>
        My highlighted <<highlight>>content!<</highlight>>   <!--1-->
      <</highlight>>

      Morbi leo risus, porta ac consectetur ac, vestibulum at eros.
      ```
      <comp.Annotation number="1">
        With `allow_nested` turned on, the content parser will detect and parse the nested
        `<<highlight>>` tags as another snippet, rather than plaintext.

        This doesn't have to be the same snippet, any configured snippet will be parsed inside
        the content parser.

        If `allow_nested` is set to false, inner snippets will still be parsed, but will not be returned.
        This means that in the above example, `My highlighted <<highlight>>content!<</highlight>>` would
        be the raw text with `allow_nested: false`. If inner snippets were not parsed, the content parser
        would end parsing at the first `<</highlight>>`, giving you the text:
        `My highlighted <<highlight>>content!`. This is the behavior of the `raw` option.
      </comp.Annotation>
      </comp.CodeBlock>
    </comp.Example>

 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="raw" type_markdown="boolean">
    A stricter version of `allow_nested: false` that performs no parsing of the inner text.
    Useful to improve the performance of the content parser, but can misbehave.

    <comp.Example>
      <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
      ```
      parser: "content"
      options:
         editor_key: highlighted_text
         raw: true
      ```
      </comp.MultiCodeBlock>

      Example usage:

      <comp.CodeBlock language="markdown" source="page.md">
      ```
      ## My blog post

      <<highlight>>
        My highlighted <<highlight>>content!<</highlight>>   <!--1-->
      <</highlight>>

      Morbi leo risus, porta ac consectetur ac, vestibulum at eros.
      ```
      <comp.Annotation number="1">
        With `raw` turned on, the content parser will perform no parsing on the text it is capturing.
        This means that the nested `<<highlight>>` will not be detected as a snippet and the first 
        `<</highlight>>` tag found will end the content parser, giving you the parsed content
        `My highlighted <<highlight>>content!`.
      </comp.Annotation>
      </comp.CodeBlock>
    </comp.Example>

 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="forbidden_tokens" type_markdown="array of strings">
    Stops parsing content as soon as one of these tokens is encountered. 
    Useful when the content parser is being greedy and consuming more input than intended.


    <comp.Example>
      <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
      ```
      parser: "content"
      options:
         editor_key: highlighted_text
         forbidden_tokens: ['<']
      ```
      </comp.MultiCodeBlock>

      Example usage:

      <comp.CodeBlock language="markdown" source="page.md">
      ```
      ## My blog post

      <<highlight>> My content <</highlight>> <!--1-->

      <<highlight>> My < content <</highlight>> <!--2-->

      Morbi leo risus, porta ac consectetur ac, vestibulum at eros.
      ```
      <comp.Annotation number="1">
        This snippet does not contain a forbidden token, so will parse and return correctly.
      </comp.Annotation>
      <comp.Annotation number="2">
        This snippet **does** contain a forbidden token, and will not match.

        This isn't particularly useful in this example, but is generally used to prevent the content
        parser from consuming the end token of itself.
      </comp.Annotation>
      </comp.CodeBlock>
    </comp.Example>

 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="optional" type_markdown="boolean">
    Whether content is required for this snippet to match.
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="style" type_markdown="Style options">
    A style object to control how content is parsed and stringified, to produce cleaner source code.

    <comp.Example>
      <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
      ```
      parser: "content"
      options:
        editor_key: highlighted_text
        style:
          inline:
            leading: " "
            trailing: " "
          block:
            leading: "\n"
            trailing: "\n"
            indent: "  "
      ```
      </comp.MultiCodeBlock>

      Example usage:

      <comp.CodeBlock language="markdown" source="page.md">
      ```
      ## My blog post

      <<highlight>>My content<</highlight>> <!--1-->

      <<highlight>>My
      multiline               <!--2-->
      content<</highlight>>

      Morbi leo risus, porta ac consectetur ac, vestibulum at eros.
      ```
      <comp.Annotation number="1">
        As this snippet contains a single line of text, it will be formatted as `inline`.
      </comp.Annotation>
      <comp.Annotation number="2">
        This snippet contains multiple lines, so will be auto-formatted as `block`.
      </comp.Annotation>
      </comp.CodeBlock>

      When the above file is opened in CloudCannon and saved, the source will be formatted to:

      <comp.CodeBlock language="markdown" source="page.md">
      ```
      ## My blog post

      <<highlight>> My content <</highlight>> <!--1-->

      <<highlight>>
        My
        multiline               <!--2-->
        content
      <</highlight>>

      Morbi leo risus, porta ac consectetur ac, vestibulum at eros.
      ```
      <comp.Annotation number="1">
        The `inline` snippet was given the leading and trailing padding of the `inline` style options.
      </comp.Annotation>
      <comp.Annotation number="2">
        The `block` snippet was given the leading and trailing padding of the `block` style options,
        and was also indented by the provided tokens.
      </comp.Annotation>
      </comp.CodeBlock>

      The style options are also stripped when the content editor loads a snippet, so the above
      snippets would be edited as `My content` and `My\nmultiline\ncontent` respectively. As a result,
      when using the style options you shouldn't need to configure the `indented_by` option for the content parser.
    </comp.Example>

 </comp.DataReferenceRow>
</comp.DataReference>



### Key values parser


<comp.Example>
  To illustrate the Key values parser, we'll look at a custom `anchor` snippet that parses the standard HTML anchor tag:

  <comp.CodeBlock language="markdown" source="page.md">
  ```
  ## My blog post

  <a href="#link" > inner </a>

  Morbi leo risus, porta ac consectetur ac, vestibulum at eros.
  ```
  </comp.CodeBlock>

  <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
  ```
  _snippets:
    anchor:
      snippet: "<<a [[args]]>>[[inner]]<</highlight>>"
      params:
        args:
          parser: key_values
          models:
            - source_key: href
          format:
            # TODO
        inner:
          parser: "content"
          options:
            editor_key: text
  ```
  </comp.MultiCodeBlock>
</comp.Example>


`models` options
<comp.DataReference>
 <comp.DataReferenceRow label="source_key" type_markdown="string">
    Specifies the key that the parser should look for in the source text.
    This will also be used as the key for editing, unless `editor_key` is set alongside.
    
    <comp.Example>
      <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
      ```
      parser: "key_values"
      options:
        models___1___:
          - source_key: href
          - source_key: class
          - source_key: target
      ```
      <comp.Annotation number="1">
        Key/value models can be specified in any order, so do not have to match the order
        of they keys in the source code.
      </comp.Annotation>
      </comp.MultiCodeBlock>

      Example usage:

      <comp.CodeBlock language="markdown" source="page.md">
      ```
      ## My blog post

      <a href="#link" target="_blank" class="my_link"> ... </a>
      Morbi leo risus, porta ac consectetur ac, vestibulum at eros.
      ```
      </comp.CodeBlock>

      When edited in CloudCannon, this will edit as the data model:

      {/* TODO: Use screenshot here instead */}

      <comp.CodeBlock language="yaml" frameless={true}>
      ```
      href: "#link"
      target: "_blank"
      class: "my_link"
      ```
      </comp.CodeBlock>
      
    </comp.Example>

 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="editor_key" type_markdown="string">
    Specifies the key that a user in CloudCannon will see when editing this value.
    This key will also be used if you want to specify any input configuration using `_inputs`.

    If not set, the `source_key` will be used, so specifying both isn't required.

    <comp.Example>
      <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
      ```
      parser: "key_values"
      options:
        models:
          - source_key: href
            editor_key: link
          - source_key: target
            editor_key: link_target
          - source_key: class
            editor_key: classnames
      ```
      </comp.MultiCodeBlock>

      Example usage:

      <comp.CodeBlock language="markdown" source="page.md">
      ```
      ## My blog post

      <a href="#link" target="_blank" class="my_link"> ... </a>
      Morbi leo risus, porta ac consectetur ac, vestibulum at eros.
      ```
      </comp.CodeBlock>

      When edited in CloudCannon, this will edit as the data model:

      {/* TODO: Use screenshot here instead */}

      <comp.CodeBlock language="yaml" frameless={true}>
      ```
      link: "#link"
      link_target: "_blank"
      classnames: "my_link"
      ```
      </comp.CodeBlock>
      
    </comp.Example>

 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="default" type_markdown="string">
    The default value for this argument, which is used when adding a new snippet to a page in CloudCannon.

    <comp.Example>
      <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
      ```
      parser: "key_values"
      options:
        models:
          - source_key: href
            default: "/"
          - source_key: target
            default: "_blank"
      ```
      </comp.MultiCodeBlock>

      With this config, adding a new `anchor` snippet to a page in CloudCannon will instantiate it
      as `<a href="/" target="_blank"> ... </a>`
    </comp.Example>

 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="optional" type_markdown="boolean">
    Whether a value must exist for this parser. Useful for long sets of key-value pairs that are not all required.

    <comp.Example>
      <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
      ```
      parser: "key_values"
      options:
        models:
          - source_key: href
          - source_key: target
            optional: true
          - source_key: class
            optional: true
      ```
      </comp.MultiCodeBlock>

      Example usage:

      <comp.CodeBlock language="markdown" source="page.md">
      ```
      ## My blog post

      <a href="#link" target="_blank" class="my_link"> ... </a> <!--1-->
      <a href="#link" target="_blank"> ... </a> <!--1-->
      <a href="#link"> ... </a> <!--1-->

      <a target="_blank"> ... </a> <!--2-->

      Morbi leo risus, porta ac consectetur ac, vestibulum at eros.
      ```
      <comp.Annotation number="1">
        All of these anchor tags will parse correctly, as they are missing either `target` or `class`
        keys from the arguments, and both are marked as `optional`.
      </comp.Annotation>
      <comp.Annotation number="2">
        This anchor tag will not be parsed, as the `href` key is absent and is not marked as `optional`.
      </comp.Annotation>
      </comp.CodeBlock>
    </comp.Example>

 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="remove_empty" type_markdown="boolean">
    Whether this key-value pair should be omitted altogether if the value is empty.
    Requires that this key is also set as optional, as otherwise the snippet would not re-parse.


    <comp.Example>
      <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
      ```
      parser: "key_values"
      options:
        models:
          - source_key: href
          - source_key: target
          - source_key: class
            optional: true
            remove_empty: true
      ```
      </comp.MultiCodeBlock>

      Example usage:

      <comp.CodeBlock language="markdown" source="page.md">
      ```
      ## My blog post

      <a href="#link" target="_blank" class=""> ... </a> <!--1-->
      <a href="#link" target="_blank"> ... </a> <!--1--> <!--2-->

      Morbi leo risus, porta ac consectetur ac, vestibulum at eros.
      ```
      <comp.Annotation number="1">
        With `remove_empty: true` both of these anchor tags will be output as `<a href="#link" target="_blank"> ... </a>`
        as the `class` key contains no value.
      </comp.Annotation>
      <comp.Annotation number="2">
        If `remove_empty: false` was set, this snippet would be output as `<a href="#link" target="_blank" class=""> ... </a>`.
        The empty `class` key will be written even if it did not originally appear in the parsed source.
      </comp.Annotation>
      </comp.CodeBlock>
    </comp.Example>

 </comp.DataReferenceRow>
</comp.DataReference>


### Literal parser

`direct:`
<comp.DataReference>
 <comp.DataReferenceRow label="literal" type_markdown="string">
    The exact literal string that should be matched.
 </comp.DataReferenceRow>
</comp.DataReference>


### Repeating literal parser


<comp.Example>
  For this example, we'll pretend that we're making a Snippet for a markdown heading. 
  This isn't something you need to do on CloudCannon since we understand Markdown natively,
  but it's a good illustration of the repeating literal parser.

  <comp.CodeBlock language="markdown" source="page.md">
  ```
  # My blog post

  Aenean lacinia bibendum nulla sed consectetur.

  ## My heading

  Morbi leo risus, porta ac consectetur ac, vestibulum at eros.
  ```
  </comp.CodeBlock>

  <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
  ```
  _snippets:
    anchor:
      snippet: "[[hashes]] [[title]]"
      params:
        args:
          parser: hashes
          literal: "#"
          minimum: 1
        title:
          parser: "content"
          options:
            editor_key: title
            forbidden_tokens: ["\n"]
  ```
  </comp.MultiCodeBlock>
</comp.Example>

<comp.DataReference>
 <comp.DataReferenceRow label="literal" type_markdown="string">
    The exact literal string that should be matched.
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="minimum" type_markdown="number">
    The minimum number of times that the literal string must occur to match this parser.
    A good example is a markdown code block, which can open with any number of backticks
    greater than three.
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="editor_key" type_markdown="string">
    Specifies a key that a user in CloudCannon will see to edit this value.
    The value returned by this parser is a number input that can be edited to change how
    many literals are output by the parser.

    <comp.Example>

      <comp.MultiCodeBlock language="yaml" translate_into={["json", "javascript"]} source="cloudcannon.config.yml">
      ```
      _snippets:
        anchor:
          snippet: "[[hashes]] [[title]]"
          params:
            args:
              parser: hashes
              literal: "#"
              minimum: 1
              editor_key: heading_level
            title:
              parser: "content"
              options:
                editor_key: title
                forbidden_tokens: ["\n"]
      ```
      </comp.MultiCodeBlock>

      Example usage:

      <comp.CodeBlock language="markdown" source="page.md">
      ```
      # My blog post <!--1-->

      Aenean lacinia bibendum nulla sed consectetur.

      ## My heading <!--1-->

      Morbi leo risus, porta ac consectetur ac, vestibulum at eros.
      ```
      <comp.Annotation number="1">
        If editing these as snippets in CloudCannon, the editor will see
        `heading_level` as a number input. Changing this value will 
        add or remove `#` to the source code to match the number.
      </comp.Annotation>
      </comp.CodeBlock>
    </comp.Example>
    
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="default" type_markdown="number">
    The default number of literals, which is used when adding a new snippet to a page in CloudCannon.
 </comp.DataReferenceRow>
</comp.DataReference>

### Optional parser

<comp.DataReference>
 <comp.DataReferenceRow label="snippet" type_markdown="string">
    A snippet string to wrap and make optional. Uses the same params
    as the outermost snippet, so may reference itself or other params.
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="remove_empty" type_markdown="boolean">
    Whether to output an empty string, or no value at all.
    This will bubble up to any outer parsers, so may control whether they
    return output.
 </comp.DataReferenceRow>
</comp.DataReference>


### Repeating parser



<comp.DataReference>
 <comp.DataReferenceRow label="snippet" type_markdown="string">
    A snippet string to wrap and make optional. Uses the same params
    as the outermost snippet, so may reference itself or other params.
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="editor_key" type_markdown="string">
    The key to use when editing the data for this snippet in CloudCannon.
    This key will become an array of objects, each containing the data for
    an iteration of the repeated snippet.
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="output_delimiter" type_markdown="string">
    TODO: Probably hide this value and favor style.between
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="default_length" type_markdown="number">
    If initializing a new snippet, how many repetitions should be created
    as a default?
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="optional" type_markdown="boolean">
    If `false` this parser requires at least one matching value. If `true`,
    matching zero times is a valid state.
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="style" type_markdown="Style options">
    A style object to control how content is parsed and stringified, to produce cleaner source code.
 </comp.DataReferenceRow>
</comp.DataReference>


## Style

<comp.DataReference>
 <comp.DataReferenceRow label="output" type_markdown="string">
    Either `inline` or `block`. For parser such as the content and repeating parsers,
    determines how to format the output.
    
    If unspecified, `inline` will be chosen when the value is a single line, otherwise `block`
    formatting will be used.
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="inline.leading" type_markdown="string">
    For inline content, what should lead the value. Useful for adding whitespace around strings.
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="inline.trailing" type_markdown="string">
    For inline content, what should trail the value. Useful for adding whitespace around strings.
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="block.leading" type_markdown="string">
    For block content, what should lead the value. Useful for adding newlines around content.
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="block.trailing" type_markdown="string">
    For block content, what should trail the value. Useful for adding newlines around content.
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="block.indent" type_markdown="string">
    For block content, how should the value be indented.
    Nested snippets only need to specify the indentation relative to their parent.
 </comp.DataReferenceRow>
</comp.DataReference>

## Format


<comp.DataReference>
 <comp.DataReferenceRow label="root_boundary" type_markdown="...">
    ...
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="remove_empty_root_boundary" type_markdown="...">
    ...
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="root_value_boundary" type_markdown="...">
    ...
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="root_value_delimiter" type_markdown="...">
    ...
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="root_value_boundary_optional" type_markdown="...">
    ...
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="root_pair_delimiter" type_markdown="...">
    ...
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="string_boundary" type_markdown="array of strings">
    The valid tokens that can bound a string. The parser will ensure the matched end token
    is the same as the start token.
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="string_escape_character" type_markdown="string">
    What character can be placed before a string boundary to escape it? (Usually `\`).
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="object_boundary" type_markdown="{ start: string, end: string }">
    For snippets which can parse object literals, what characters start and end an object?
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="object_value_delimiter" type_markdown="string">
    Within an object, what character(s) separate a key and a value?
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="object_pair_delimiter" type_markdown="string">
    Within an object, what character(s) separate each key-value pair.
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="array_boundary" type_markdown="{ start: string, end: string }">
    For snippets which can parse array literals, what characters start and end an array?
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="array_delimiter" type_markdown="string">
    Within an array, what character(s) separate each value"?
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="forbidden_tokens" type_markdown="string">
    For the given parser, what tokens are strictly not allowed in the value.
    Most often used to limit what the content parser will consume.
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="allow_booleans" type_markdown="boolean">
    Whether unquoted booleans like `true` and `false` can be used as values.
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="allow_numbers" type_markdown="boolean">
    Whether unquoted numbers like `5` and `-0.4` can be used as values.
 </comp.DataReferenceRow>
 <comp.DataReferenceRow label="allow_implied_values" type_markdown="boolean">
    When parsing key-value pairs, can a key be specified without a value to imply a value of `true`?
 </comp.DataReferenceRow>
</comp.DataReference>
